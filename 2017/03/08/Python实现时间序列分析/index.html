<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  

  

  
    

    
  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="统计学,时间序列,人工智能,ARIMA," />





  <link rel="alternate" href="/atom.xml" title="蘑菇先生学习记" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/picture/logo.ico?v=5.1.0" />






<meta name="description" content="前面花了两章篇幅介绍了时间序列模型的数学基础。 ARIMA时间序列模型(一)和ARIMA时间序列模型(二) 。本文重点介绍使用python开源库进行时间序列模型实践。 基本概念回顾一下自回归移动平均模型ARMA，它主要由两部分组成：AR代表p阶自回归过程，MA代表q阶移动平均过程，形式如下：$$Z_t=\theta_0+\phi_1 Z_{t-1}+\phi_2 Z_{t-2}+…+\phi_p">
<meta name="keywords" content="统计学,时间序列,人工智能,ARIMA">
<meta property="og:type" content="article">
<meta property="og:title" content="Python实现时间序列分析">
<meta property="og:url" content="xtf615.com/2017/03/08/Python实现时间序列分析/index.html">
<meta property="og:site_name" content="蘑菇先生学习记">
<meta property="og:description" content="前面花了两章篇幅介绍了时间序列模型的数学基础。 ARIMA时间序列模型(一)和ARIMA时间序列模型(二) 。本文重点介绍使用python开源库进行时间序列模型实践。 基本概念回顾一下自回归移动平均模型ARMA，它主要由两部分组成：AR代表p阶自回归过程，MA代表q阶移动平均过程，形式如下：$$Z_t=\theta_0+\phi_1 Z_{t-1}+\phi_2 Z_{t-2}+…+\phi_p">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="/picture/machine-learning/arima5.jpg">
<meta property="og:image" content="/picture/machine-learning/arima6.jpg">
<meta property="og:image" content="/picture/machine-learning/arima7.jpg">
<meta property="og:image" content="/picture/machine-learning/arima8.jpg">
<meta property="og:image" content="/picture/machine-learning/arima9.jpg">
<meta property="og:image" content="/picture/machine-learning/arima10.jpg">
<meta property="og:image" content="/picture/machine-learning/arima11.jpg">
<meta property="og:image" content="/picture/machine-learning/arima12.jpg">
<meta property="og:image" content="/picture/machine-learning/arima13.jpg">
<meta property="og:image" content="/picture/machine-learning/arima14.jpg">
<meta property="og:image" content="/picture/machine-learning/arima15.jpg">
<meta property="og:image" content="/picture/machine-learning/arima16.jpg">
<meta property="og:image" content="/picture/machine-learning/arima17.jpg">
<meta property="og:image" content="/picture/machine-learning/arima18.jpg">
<meta property="og:image" content="/picture/machine-learning/arima19.jpg">
<meta property="og:image" content="/picture/machine-learning/arima20.jpg">
<meta property="og:image" content="/picture/machine-learning/arima21.jpg">
<meta property="og:image" content="/picture/machine-learning/arima22.jpg">
<meta property="og:image" content="/picture/machine-learning/arima26.jpg">
<meta property="og:image" content="/picture/machine-learning/arima23.jpg">
<meta property="og:image" content="/picture/machine-learning/arima24.jpg">
<meta property="og:image" content="/picture/machine-learning/arima25.jpg">
<meta property="og:image" content="/picture/machine-learning/arima27.jpg">
<meta property="og:image" content="/picture/machine-learning/arima28.jpg">
<meta property="og:image" content="/picture/machine-learning/arima29.jpg">
<meta property="og:updated_time" content="2019-12-05T07:51:19.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python实现时间序列分析">
<meta name="twitter:description" content="前面花了两章篇幅介绍了时间序列模型的数学基础。 ARIMA时间序列模型(一)和ARIMA时间序列模型(二) 。本文重点介绍使用python开源库进行时间序列模型实践。 基本概念回顾一下自回归移动平均模型ARMA，它主要由两部分组成：AR代表p阶自回归过程，MA代表q阶移动平均过程，形式如下：$$Z_t=\theta_0+\phi_1 Z_{t-1}+\phi_2 Z_{t-2}+…+\phi_p">
<meta name="twitter:image" content="/picture/machine-learning/arima5.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="xtf615.com/2017/03/08/Python实现时间序列分析/"/>





  <title> Python实现时间序列分析 | 蘑菇先生学习记 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">蘑菇先生学习记</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <!-- <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form> -->

<!-- <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'WgLy48WeXh1aXsWx1x7L','2.0.0');
</script> -->



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="xtf615.com/2017/03/08/Python实现时间序列分析/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuetf">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/11912425?v=3&u=11f9f5dc75aaf84f020a06c0b9cb2b6f401c586b&s=400">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="蘑菇先生学习记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="蘑菇先生学习记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Python实现时间序列分析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-08T09:54:58+08:00">
                2017-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/时间序列分析/" itemprop="url" rel="index">
                    <span itemprop="name">时间序列分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 阅读量 
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>前面花了两章篇幅介绍了时间序列模型的数学基础。 <a href="/2017/03/07/ARIMA时间序列模型/">ARIMA时间序列模型(一)</a>和<a href="/2017/03/07/ARIMA时间序列模型-二/">ARIMA时间序列模型(二)</a> 。本文重点介绍使用python开源库进行时间序列模型实践。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>回顾一下自回归移动平均模型ARMA，它主要由两部分组成：AR代表p阶自回归过程，MA代表q阶移动平均过程，形式如下：<br>$$Z_t=\theta_0+\phi_1 Z_{t-1}+\phi_2 Z_{t-2}+…+\phi_p Z_{t-p} \\\\<br>+a_t-\theta_1a_{t-1}-\theta_2a_{t-2}-…-\theta_qa_{t-q}$$<br>为了方便，我们重写以上等式为：<br>$$\phi(B)Z_t=\theta_0+\theta(B)a_t \\\\<br>其中，\phi(x)和\theta(x)分别是AR模型和MA模型的的特征多项式$$<br>$$\phi(x)=1-\phi_1x-\phi_2x^2-…-\phi_px^p$$<br>$$\theta(x)=1-\theta_1x-\theta_2x^2-…-\theta_px^q$$<br>根据前两篇的分析，我们总结ARMA模型的性质如下：<br><img src="/picture/machine-learning/arima5.jpg" alt="arima"><br><a id="more"></a></p>
<h1 id="p值检验"><a href="#p值检验" class="headerlink" title="p值检验"></a>p值检验</h1><p>　　在开始之前，我们首先回顾一下p值检验。<br>　　一般地，用X表示检验的统计量，当H0为真时，可由样本数据计算出该统计量的值C，根据检验统计量X的具体分布，可求出P值。具体地说：</p>
<ul>
<li>左侧检验的P值为检验统计量X小于样本统计值C的概率，即：P = P{ X &lt; C}</li>
<li>右侧检验的P值为检验统计量X大于样本统计值C的概率：P = P{ X &gt; C}</li>
<li>双侧检验的P值为检验统计量X落在样本统计值C为端点的尾部区域内的概率的2倍：P = 2P{ X &gt; C} (当C位于分布曲线的右端时) 或P = 2P{ X&lt; C}(当C位于分布曲线的左端时) 。若X服从正态分布和t分布，其分布曲线是关于纵轴对称的，故其P值可表示为P=P{|X|&gt;C}。<br>计算出P值后，将给定的显著性水平α与P值比较，就可作出检验的结论：<br>如果\(p &lt; α\)值，则在显著性水平α下拒绝原假设。<br>如果\(P \geq α\)值，则在显著性水平α下接受原假设。</li>
</ul>
<h1 id="pandas数据操作"><a href="#pandas数据操作" class="headerlink" title="pandas数据操作"></a>pandas数据操作</h1><p>使用pandas来加载数据，并对数据索引进行转换，使用日期作为索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dateparse = <span class="keyword">lambda</span> dates:pd.datetime.strptime(dates,<span class="string">'%Y-%m'</span>)</span><br><span class="line">data=pd.read_csv(<span class="string">'AirPassengers.csv'</span>,parse_dates=<span class="string">'Month'</span>,index_col=<span class="string">'Month'</span>,date_parser=dateparse);</span><br><span class="line"><span class="keyword">print</span> data.head()</span><br><span class="line"><span class="comment"># 数据如下所示：</span></span><br><span class="line">Month                  </span><br><span class="line"></span><br><span class="line"><span class="number">1949</span><span class="number">-01</span><span class="number">-01</span>          <span class="number">112</span></span><br><span class="line"></span><br><span class="line"><span class="number">1949</span><span class="number">-02</span><span class="number">-01</span>          <span class="number">118</span></span><br><span class="line"></span><br><span class="line"><span class="number">1949</span><span class="number">-03</span><span class="number">-01</span>          <span class="number">132</span></span><br><span class="line"></span><br><span class="line"><span class="number">1949</span><span class="number">-04</span><span class="number">-01</span>          <span class="number">129</span></span><br><span class="line"></span><br><span class="line"><span class="number">1949</span><span class="number">-05</span><span class="number">-01</span>          <span class="number">121</span></span><br></pre></td></tr></table></figure>
<p>接着绘制数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ts = data[<span class="string">'#Passengers'</span>]</span><br><span class="line">plt.plot(ts)</span><br></pre></td></tr></table></figure>
<p><img src="/picture/machine-learning/arima6.jpg" alt="arma"></p>
<p>非常清晰的看到，随着季节性的变动，飞机乘客的数量总体上是在不断增长的。但是，不是经常都可以获得这样清晰的视觉体验。我们可以通过下面的方法测试稳定性。</p>
<h1 id="稳定性检测"><a href="#稳定性检测" class="headerlink" title="稳定性检测"></a>稳定性检测</h1><ul>
<li><strong>绘制滚动统计</strong>：我们可以绘制移动平均数和移动方差，观察它是否随着时间变化。</li>
<li><strong>ADF检验：</strong>这是一种检查数据稳定性的统计测试。无效假设：时间序列是不稳定的。测试结果由测试统计量和一些置信区间的临界值组成。如果“测试统计量”少于“临界值”，我们可以拒绝无效假设，并认为序列是稳定的。或者根据前面提高的p值检验，如果p值小于显著性水平，我们可以拒绝无效假设，认为序列稳定。</li>
</ul>
<h2 id="滚动统计"><a href="#滚动统计" class="headerlink" title="滚动统计"></a>滚动统计</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rolling_statistics</span><span class="params">(timeseries)</span>:</span></span><br><span class="line">    <span class="comment">#Determing rolling statistics</span></span><br><span class="line">    rolmean = pd.rolling_mean(timeseries, window=<span class="number">12</span>)</span><br><span class="line">    rolstd = pd.rolling_std(timeseries, window=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#Plot rolling statistics:</span></span><br><span class="line">    orig = plt.plot(timeseries, color=<span class="string">'blue'</span>,label=<span class="string">'Original'</span>)</span><br><span class="line">    mean = plt.plot(rolmean, color=<span class="string">'red'</span>, label=<span class="string">'Rolling Mean'</span>)</span><br><span class="line">    std = plt.plot(rolstd, color=<span class="string">'black'</span>, label = <span class="string">'Rolling Std'</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">'best'</span>)</span><br><span class="line">    plt.title(<span class="string">'Rolling Mean &amp; Standard Deviation'</span>)</span><br><span class="line">    plt.show(block=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure>
<p>pd.rolling_mean有两个参数，第一个是输入数据，第二个是窗口大小。假设有个序列是，1  2  3  3  5  8  6  9，如果窗口大小为3，那么移动平均数计算过程如下： 第一步: (1+2+3)/3 =2;    第二步:往右移动一个数据，(2+3+3)/3=2.667;  第三步, (3+3+5)/3=3.667;  第四步：(3+5+8)/3=5.333; 第四步: (5+8+6)/3=6.333; 第五步;(8+6+9)/3=7.667;  因此移动平均数序列为： NA NA 2  2.667  3.667  5.3333   6.333  7.667.  共用n-windows+1个数。</p>
<p><img src="/picture/machine-learning/arima7.jpg" alt="arma"></p>
<p>移动标准差类似，只不过把求平均变成了求标准差。</p>
<p>绘图如下：可以看出移动平均数仍然是上升趋势，而移动标准差相对比较平稳。</p>
<p><img src="/picture/machine-learning/arima8.jpg" alt="arma"></p>
<h2 id="ADF检验"><a href="#ADF检验" class="headerlink" title="ADF检验"></a>ADF检验</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> statsmodels.tsa.stattools <span class="keyword">import</span> adfuller</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adf_test</span><span class="params">(timeseries)</span>:</span></span><br><span class="line">    rolling_statistics(timeseries)<span class="comment">#绘图</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Results of Augment Dickey-Fuller Test:'</span></span><br><span class="line">    dftest = adfuller(timeseries, autolag=<span class="string">'AIC'</span>)</span><br><span class="line">    dfoutput = pd.Series(dftest[<span class="number">0</span>:<span class="number">4</span>], index=[<span class="string">'Test Statistic'</span>,<span class="string">'p-value'</span>,<span class="string">'#Lags Used'</span>,<span class="string">'Number of Observations Used'</span>])</span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> dftest[<span class="number">4</span>].items():</span><br><span class="line">        dfoutput[<span class="string">'Critical Value (%s)'</span>%key] = value</span><br><span class="line">    <span class="keyword">print</span> dfoutput</span><br></pre></td></tr></table></figure>
<p><img src="/picture/machine-learning/arima9.jpg" alt="arma"></p>
<p>上述输出如何解读?</p>
<ul>
<li>Test statistic：代表检验统计量</li>
<li>p-value：代表p值检验的概率</li>
<li>Lags used：使用的滞后k，autolag=AIC时会自动选择滞后</li>
<li>Number of Observations Used：样本数量</li>
<li>Critical Value(5%) : 显著性水平为5%的临界值。</li>
</ul>
<p>ADF检验</p>
<ul>
<li>假设是存在单位根，即不平稳； </li>
<li>显著性水平，1%：严格拒绝原假设；5%：拒绝原假设，10%类推。</li>
<li>看P值和显著性水平a的大小，p值越小，小于显著性水平的话，就拒绝原假设，认为序列是平稳的；大于的话，不能拒绝，认为是不平稳的</li>
<li>看检验统计量和临界值，检验统计量小于临界值的话，就拒绝原假设，认为序列是平稳的；大于的话，不能拒绝，认为是不平稳的</li>
</ul>
<p>根据上文提到的p值检验以及上面的结果，我们可以发现p=0.99&gt;10%&gt;5%&gt;1%, 并且检验统计量0.815&gt;&gt;-2.58&gt;-2.88&gt;-3.48，因此可以认定原序列不平稳。</p>
<p>先让我们弄明白是什么导致时间序列不稳定。两个主要原因。</p>
<ul>
<li><strong>趋势-随着时间产生不同的平均值。</strong>举例：在飞机乘客这个案例中，我们看到总体上，飞机乘客的数量是在不断增长的。</li>
<li><strong>季节性-特定时间框架内的变化。</strong>举例：在特定的月份购买汽车的人数会有增加的趋势，因为车价上涨或者节假日到来。</li>
</ul>
<p>我们的基本原理是，通过建模并估计趋势和季节性这些因素，并从时间序列中移除，来获得一个稳定的时间序列，然后再使用统计预测技术来处理时间序列，最后将预测得到的数据，通过加入趋势和季节性等约束，来回退到原始时间序列数据。</p>
<h1 id="平稳性处理"><a href="#平稳性处理" class="headerlink" title="平稳性处理"></a>平稳性处理</h1><p>　　消除趋势的第一个方法是转换。例如,在本例中,我们可以清楚地看到该时间序列有显著趋势。所以我们可以通过变换，惩罚较高值而不是较小值。这可以采用对数,  平方根,立方跟等等。</p>
<h2 id="对数变换"><a href="#对数变换" class="headerlink" title="对数变换"></a>对数变换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ts_log = np.log(ts)</span><br><span class="line">plt.plot(ts_log)</span><br></pre></td></tr></table></figure>
<p><img src="/picture/machine-learning/arima10.jpg" alt="arma"></p>
<p>在这个例子中,很容易看到一个向前的趋势。但是它表现的不是很直观。我们可以使用一些技术来对这个趋势建模, 然后将它从序列中删除。最常用的方法有:</p>
<ul>
<li><strong>平滑-取滚动平均数</strong></li>
<li><strong>差分</strong></li>
<li><strong>分解</strong></li>
</ul>
<h2 id="移动平均数"><a href="#移动平均数" class="headerlink" title="移动平均数"></a>移动平均数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">moving_avg = pd.rolling_mean(ts_log,<span class="number">12</span>)</span><br><span class="line">plt.plot(ts_log)</span><br><span class="line">plt.plot(moving_avg,color=<span class="string">'red'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/picture/machine-learning/arima11.jpg" alt="arma"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#做差</span></span><br><span class="line">ts_log_moving_avg_diff = ts_log - moving_avg</span><br><span class="line">ts_log_moving_avg_diff.head(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/picture/machine-learning/arima12.jpg" alt="arma"></p>
<p>前11个数是NA</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adf_test(ts_log_moving_avg_diff)</span><br></pre></td></tr></table></figure>
<p><img src="/picture/machine-learning/arima13.jpg" alt="arma"></p>
<p>可以发现通过了5%和10%的显著性检验，即在该水平下，拒绝原假设，认为序列是平稳的，但是没有通过1%的检验。</p>
<p><strong>指数加权移动平均</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expwighted_avg=pd.ewma(ts_log,halflife=<span class="number">12</span>)</span><br><span class="line">plt.plot(ts_log)</span><br><span class="line">plt.plot(expwighted_avg, color=<span class="string">'red'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/picture/machine-learning/arima14.jpg" alt="arma"></p>
<p>前面移动平均数需要指定window,并且对所有的数一视同仁；这里采用指数加权移动平均方法，会对当前的数据加大权重，对过去的数据减小权重。halflife半衰期，用来定义衰减量。其他参数,如跨度span和质心com也可以用来定义衰减。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#做差</span></span><br><span class="line">ts_log_ewma_diff = ts_log - expwighted_avg</span><br><span class="line">adf_test(ts_log_ewma_diff)</span><br></pre></td></tr></table></figure>
<p><img src="/picture/machine-learning/arima15.jpg" alt="arma"></p>
<p>可以发现，经过指数移动平均后，再做差的结果，已经能够通过1%显著性水平检验了。</p>
<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#步长为1的一阶差分</span></span><br><span class="line">ts_log_diff = ts_log - ts_log.shift(periods=<span class="number">1</span>)</span><br><span class="line">plt.plot(ts_log_diff)</span><br></pre></td></tr></table></figure>
<p>我们首先使用步长为1的一阶差分，得到如下图：</p>
<p><img src="/picture/machine-learning/arima16.jpg" alt="arma"></p>
<p>接着进行adf检验，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#只通过了10%的检验</span><br><span class="line">ts_log_diff.dropna(inplace=True)</span><br><span class="line">test_stationarity(ts_log_diff)</span><br></pre></td></tr></table></figure>
<p><img src="/picture/machine-learning/arima17.jpg" alt="arma"></p>
<p>可以发现只通过了10%的显著性水平检验。</p>
<p><strong>二阶差分</strong></p>
<p>我们继续进行二阶差分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一阶差分：Y(k)=X(k+1)-X(k)</span></span><br><span class="line"><span class="comment">#二阶差分：Y(k)的一阶差分Z(k)=Y(k+1)-Y(k)=X(k+2)-2*X(k+1)+X(k)为此函数的二阶差分</span></span><br><span class="line">ts_log_diff = ts_log - ts_log.shift(periods=<span class="number">1</span>)</span><br><span class="line">ts_log_diff2 = ts_log_diff - ts_log_diff.shift(periods=<span class="number">1</span>)</span><br><span class="line">plt.plot(ts_log_diff2)</span><br></pre></td></tr></table></figure>
<p><img src="/picture/machine-learning/arima18.jpg" alt="arma"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#二阶差分检验</span><br><span class="line">#可以看到，二阶差分，p值非常小，小于1%，检验统计量也明显小于%1的临界值。因此认定为很平稳</span><br><span class="line">ts_log_diff2.dropna(inplace=True)</span><br><span class="line">adf_test(ts_log_diff2)</span><br></pre></td></tr></table></figure>
<p><img src="/picture/machine-learning/arima19.jpg" alt="arma"></p>
<p>对二阶差分进行adf检验,可以看到，二阶差分，p值非常小，小于1%，检验统计量也明显小于%1的临界值。因此认定为很平稳.</p>
<h2 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h2><p>建立有关趋势和季节性的模型，并从模型中删除它们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#时间序列分解</span><br><span class="line">from statsmodels.tsa.seasonal import seasonal_decompose</span><br><span class="line">decomposition = seasonal_decompose(ts_log)</span><br><span class="line">trend = decomposition.trend</span><br><span class="line">seasonal = decomposition.seasonal</span><br><span class="line">residual = decomposition.resid</span><br><span class="line"></span><br><span class="line">plt.subplot(411)</span><br><span class="line">plt.plot(ts_log,label=&apos;Original&apos;)</span><br><span class="line">plt.legend(loc=&apos;best&apos;)</span><br><span class="line">plt.subplot(412)</span><br><span class="line">plt.plot(trend, label=&apos;Trend&apos;)</span><br><span class="line">plt.legend(loc=&apos;best&apos;)</span><br><span class="line">plt.subplot(413);</span><br><span class="line">plt.plot(seasonal,label=&apos;Seasonality&apos;)</span><br><span class="line">plt.legend(loc=&apos;best&apos;)</span><br><span class="line">plt.subplot(414)</span><br><span class="line">plt.plot(residual, label=&apos;Residuals&apos;)</span><br><span class="line">plt.legend(loc=&apos;best&apos;)</span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></table></figure>
<p><img src="/picture/machine-learning/arima20.jpg" alt="arma"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#对残差进行ADF检验</span><br><span class="line">#可以发现序列非常平稳</span><br><span class="line">ts_log_decompose = residual</span><br><span class="line">ts_log_decompose.dropna(inplace=True)</span><br><span class="line">adf_test(ts_log_decompose)</span><br></pre></td></tr></table></figure>
<p><img src="/picture/machine-learning/arima21.jpg" alt="arma"></p>
<p>对残差进行ADF检验，可以发现序列非常平稳。</p>
<h1 id="时间序列建模"><a href="#时间序列建模" class="headerlink" title="时间序列建模"></a>时间序列建模</h1><h2 id="平稳性检验"><a href="#平稳性检验" class="headerlink" title="平稳性检验"></a>平稳性检验</h2><p>平稳性检验的目的是为了判断序列是否平稳，如果不平稳，需要采取一定的措施进行平稳性处理，常见的方法是差分，我们需要选择合适的差分阶数。只要能够通过1%显著性检测，差分阶数就是合理的，我们希望阶数越小越好。</p>
<h3 id="ADF检验-1"><a href="#ADF检验-1" class="headerlink" title="ADF检验"></a>ADF检验</h3><p>ADF检验前文已经说过，用于判断序列是否平稳。</p>
<h3 id="自相关图和偏自相关图"><a href="#自相关图和偏自相关图" class="headerlink" title="自相关图和偏自相关图"></a>自相关图和偏自相关图</h3><p>前面我们对数据进行ADF检验，判断序列是否平稳，这里我们使用自相关图和偏自相关图对数据平稳性再次进行验证，一阶差分如下图：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acf_pacf_plot</span><span class="params">(ts_log_diff)</span>:</span></span><br><span class="line">    sm.graphics.tsa.plot_acf(ts_log_diff,lags=<span class="number">40</span>) <span class="comment">#ARIMA,q</span></span><br><span class="line">    sm.graphics.tsa.plot_pacf(ts_log_diff,lags=<span class="number">40</span>) <span class="comment">#ARIMA,p</span></span><br><span class="line">acf_pacf_plot(ts_log_diff) <span class="comment">#调用一阶差分</span></span><br></pre></td></tr></table></figure>
<p><img src="/picture/machine-learning/arima22.jpg" alt="arma"></p>
<p>可以看出，一阶差分自相关和偏相系数拖尾特点明显。p=1,q=1</p>
<h2 id="参数选择"><a href="#参数选择" class="headerlink" title="参数选择"></a>参数选择</h2><h3 id="差分阶数选择"><a href="#差分阶数选择" class="headerlink" title="差分阶数选择"></a>差分阶数选择</h3><p>我们发现，ARIMA该开源库，不支持3阶以上的差分。我们唯一的办法是先数据差分好，再传入模型进行建模。但是这样也带来了回退数据到原始序列数据的难度。</p>
<p><img src="/picture/machine-learning/arima26.jpg" alt="arma"></p>
<p>这里开发了差分和回退的方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 差分操作,d代表差分序列，比如[1,1,1]可以代表3阶差分。  [12,1]可以代表第一次差分偏移量是12，第二次差分偏移量是1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diff_ts</span><span class="params">(ts, d)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> shift_ts_list</span><br><span class="line">    <span class="comment">#  动态预测第二日的值时所需要的差分序列</span></span><br><span class="line">    <span class="keyword">global</span> last_data_shift_list <span class="comment">#这个序列在恢复过程中需要用到</span></span><br><span class="line">    shift_ts_list = []</span><br><span class="line">    last_data_shift_list = []</span><br><span class="line">    tmp_ts = ts</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> d:</span><br><span class="line">        last_data_shift_list.append(tmp_ts[-i])</span><br><span class="line">        <span class="keyword">print</span> last_data_shift_list</span><br><span class="line">        shift_ts = tmp_ts.shift(i)</span><br><span class="line">        shift_ts_list.append(shift_ts)</span><br><span class="line">        tmp_ts = tmp_ts - shift_ts</span><br><span class="line">    tmp_ts.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">return</span> tmp_ts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还原操作</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_diff_recover</span><span class="params">(predict_value, d)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(predict_value, float):</span><br><span class="line">        tmp_data = predict_value</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(d)):</span><br><span class="line">            tmp_data = tmp_data + last_data_shift_list[-i<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">elif</span> isinstance(predict_value, np.ndarray):</span><br><span class="line">        tmp_data = predict_value[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(d)):</span><br><span class="line">            tmp_data = tmp_data + last_data_shift_list[-i<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tmp_data = predict_value</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(d)):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                tmp_data = tmp_data.add(shift_ts_list[-i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">'What you input is not pd.Series type!'</span>)</span><br><span class="line">        tmp_data.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">return</span> tmp_data <span class="comment"># return np.exp(tmp_data)也可以return到最原始，tmp_data是对原始数据取对数的结果</span></span><br></pre></td></tr></table></figure>
<p>使用的时候，必须先调用diff_ts进行差分处理，然后进行建模，将预测数据传入predict_diff_recover方法进行还原。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d=[<span class="number">1</span>, <span class="number">1</span>] <span class="comment"># 定义差分序列</span></span><br><span class="line">ts_log = np.log(ts)</span><br><span class="line">diffed_ts = diff_ts(ts_log, d) </span><br><span class="line"><span class="comment"># model = arima_model(diffed_ts)构建模型</span></span><br><span class="line">predict_ts = model.properModel.predict() <span class="comment">#预测，这是对训练数据的预测</span></span><br><span class="line">diff_recover_ts = predict_diff_recover(predict_ts, d)</span><br><span class="line">log_recover = np.exp(diff_recover_ts) <span class="comment">#恢复对数前数据，该数据可以和原始数据ts进行作图对比</span></span><br></pre></td></tr></table></figure>
<p>差分阶数的选择通常越小越好，只要能够使得序列稳定就行。我们可以通过选择不同的阶数，然后进行平稳性检测，选择平稳性表现良好的阶数就行，一般一阶和二阶用的比较多。</p>
<h3 id="p和q选择"><a href="#p和q选择" class="headerlink" title="p和q选择"></a>p和q选择</h3><p>　　差分阶数确定后，我们需要确定p和q. 对于个数不多的时序数据，我们可以通过观察自相关图和偏相关图来进行模型识别，倘若我们要分析的时序数据量较多，例如要预测每只股票的走势，我们就不可能逐个去调参了。这时我们可以依据BIC准则识别模型的p, q值，通常认为BIC值越小的模型相对更优。这里我简单介绍一下BIC准则，它综合考虑了残差大小和自变量的个数，残差越小BIC值越小，自变量个数越多BIC值越大。个人觉得BIC准则就是对模型过拟合设定了一个标准。当然，我们也可以使用AIC指标。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注意这里面使用的ts_log_diff是经过合适阶数的差分之后的数据，上文中提到ARIMA该开源库，不支持3阶以上的#差分。所以我们需要提前将数据差分好再传入</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> statsmodels.tsa.arima_model <span class="keyword">import</span> ARMA</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_proper_model</span><span class="params">(ts_log_diff, maxLag)</span>:</span></span><br><span class="line">    best_p = <span class="number">0</span> </span><br><span class="line">    best_q = <span class="number">0</span></span><br><span class="line">    best_bic = sys.maxint</span><br><span class="line">    best_model=<span class="keyword">None</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> np.arange(maxLag):</span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> np.arange(maxLag):</span><br><span class="line">            model = ARMA(ts_log_diff, order=(p, q))</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                results_ARMA = model.fit(disp=<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            bic = results_ARMA.bic</span><br><span class="line">            <span class="keyword">print</span> bic, best_bic</span><br><span class="line">            <span class="keyword">if</span> bic &lt; best_bic:</span><br><span class="line">                best_p = p</span><br><span class="line">                best_q = q</span><br><span class="line">                best_bic = bic</span><br><span class="line">                best_model = results_ARMA</span><br><span class="line">    <span class="keyword">return</span> best_p,best_q,best_model</span><br><span class="line">_proper_model(ts_log_diff, <span class="number">10</span>) <span class="comment">#对一阶差分求最优p和q</span></span><br></pre></td></tr></table></figure>
<p>通过上述方法可以得到最优的p和q。</p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>我们使用一阶差分进行构建。</p>
<h3 id="AR-p-模型"><a href="#AR-p-模型" class="headerlink" title="AR(p)模型"></a>AR(p)模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AR模型，q=0</span></span><br><span class="line"><span class="comment">#RSS是残差平方和</span></span><br><span class="line"><span class="comment"># disp为-1代表不输出收敛过程的信息，True代表输出</span></span><br><span class="line">model = ARIMA(ts_log,order=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)) <span class="comment">#第二个参数代表使用了一阶差分</span></span><br><span class="line">results_AR = model.fit(disp=<span class="number">-1</span>)</span><br><span class="line">plt.plot(ts_log_diff)</span><br><span class="line">plt.plot(results_AR.fittedvalues, color=<span class="string">'red'</span>) <span class="comment">#红色线代表预测值</span></span><br><span class="line">plt.title(<span class="string">'RSS:%.4f'</span> % sum((results_AR.fittedvalues-ts_log_diff)**<span class="number">2</span>))<span class="comment">#残差平方和</span></span><br></pre></td></tr></table></figure>
<p><img src="/picture/machine-learning/arima23.jpg" alt="arma"></p>
<h3 id="MA-q-模型"><a href="#MA-q-模型" class="headerlink" title="MA(q)模型"></a>MA(q)模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#MA模型 p=0</span><br><span class="line">model = ARIMA(ts_log,order=(0,1,1))</span><br><span class="line">results_MA = model.fit(disp=-1)</span><br><span class="line">plt.plot(ts_log_diff)</span><br><span class="line">plt.plot(results_MA.fittedvalues, color=&apos;red&apos;)</span><br><span class="line">plt.title(&apos;RSS: %.4f&apos;% sum((results_MA.fittedvalues-ts_log_diff)**2))</span><br></pre></td></tr></table></figure>
<p><img src="/picture/machine-learning/arima24.jpg" alt="arma"></p>
<h3 id="ARIMA-p-q-模型"><a href="#ARIMA-p-q-模型" class="headerlink" title="ARIMA(p,q)模型"></a>ARIMA(p,q)模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ARIMA</span></span><br><span class="line">model = ARIMA(ts_log, order=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))  </span><br><span class="line">results_ARIMA = model.fit(disp=<span class="number">-1</span>)  <span class="comment">#不展示信息</span></span><br><span class="line">plt.plot(ts_log_diff)</span><br><span class="line">plt.plot(results_ARIMA.fittedvalues, color=<span class="string">'red'</span>)<span class="comment">#和下面这句结果一样</span></span><br><span class="line">plt.plot(results_ARIMA.predict(), color=<span class="string">'black'</span>)<span class="comment">#predict得到的就是fittedvalues，只是差分的结果而已。还需要继续回退</span></span><br><span class="line">plt.title(<span class="string">'RSS: %.4f'</span>% sum((results_ARIMA.fittedvalues-ts_log_diff)**<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/picture/machine-learning/arima25.jpg" alt="arma"></p>
<p>可以发现，ARIMA在AR和MA基础上，RSS有所减少，故模型有所提高。</p>
<p>我们使用上文中提高的p和q选择方法，对一阶差分结果进行p和q选择。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_proper_model(ts_log_diff, <span class="number">9</span>)</span><br><span class="line"><span class="comment"># 输出最优结果如下：</span></span><br><span class="line">(<span class="number">8</span>, <span class="number">7</span>, &lt;statsmodels.tsa.arima_model.ARMAResultsWrapper at <span class="number">0xb4e2898</span>&gt;)</span><br></pre></td></tr></table></figure>
<p>故可以使用p=8,q=7再次进行测试。得到如下结果：</p>
<p><img src="/picture/machine-learning/arima27.jpg" alt="arma"></p>
<p>可以发现，残差平方和RSS已经优化到0.40了。</p>
<h2 id="数据还原"><a href="#数据还原" class="headerlink" title="数据还原"></a>数据还原</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ts_log_diff = diff_ts(ts_log, d=[1])#调用差分方法，方便后续还原</span><br><span class="line">model = ARIMA(ts_log, order=(8, 1, 7))  #建模</span><br><span class="line">results_ARIMA = model.fit(disp=-1)  #fit</span><br><span class="line">predict_ts = model.predict() #对训练数据进行预测</span><br><span class="line"></span><br><span class="line">#还原</span><br><span class="line">diff_recover_ts = predict_diff_recover(predict_ts, d=[1])#恢复数据</span><br><span class="line">log_recover = np.exp(diff_recover_ts)#还原对数前数据</span><br><span class="line"></span><br><span class="line">#绘图</span><br><span class="line">#ts = ts[log_recover.index]#排除空的数据</span><br><span class="line">plt.plot(ts,color=&quot;blue&quot;,label=&apos;Original&apos;)</span><br><span class="line">plt.plot(log_recover,color=&apos;red&apos;,label=&apos;Predicted&apos;)</span><br><span class="line">plt.legend(loc=&apos;best&apos;)</span><br><span class="line">plt.title(&apos;RMSE: %.4f&apos;% np.sqrt(sum((log_recover-ts)**2)/len(ts)))#RMSE,残差平方和开根号，即标准差</span><br></pre></td></tr></table></figure>
<p><img src="/picture/machine-learning/arima28.jpg" alt="arma"></p>
<h2 id="预测未来走势"><a href="#预测未来走势" class="headerlink" title="预测未来走势"></a>预测未来走势</h2><p>使用forecast进行预测，参数为预测值个数。这个得到的就是进行自动差分还原后的数据，因为我们建立模型的时候ARIMA(p,1,q), 第二个参数就是差分阶数，forecast会将结果恢复回差分前的数据，因此我们直接将结果通过np.exp来恢复到最原始数据即可。但是ARIMA只支持最多2阶差分，因此我们可以使用ARMA模型，将我们手动差分完的数据传入。最后预测的时候，使用我们自定义的差分还原方法，对预测得到的值进行差分还原。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># forecast方法会自动进行差分还原，当然仅限于支持的1阶和2阶差分</span><br><span class="line">forecast_n = 12 #预测未来12个月走势</span><br><span class="line">forecast_ARIMA_log = results_ARIMA.forecast(forecast_n)</span><br><span class="line">forecast_ARIMA_log = forecast_ARIMA_log[0]</span><br><span class="line">print forecast_ARIMA_log</span><br><span class="line"></span><br><span class="line">##如下是差分还原后的数据：</span><br><span class="line">[6.15487901  6.12150398  6.13788758  6.19511156  6.27419885  6.40259838</span><br><span class="line">  6.57706431  6.49128697  6.35429917  6.2679321   6.13597822  6.18507789</span><br><span class="line">  6.26245365  6.24740859  6.24775066  6.29778253  6.3935587   6.54015482</span><br><span class="line">  6.67409705  6.62124844]</span><br></pre></td></tr></table></figure>
<p>我们希望能够将预测的数据和原来的数据绘制在一起，为了实现这一目的，我们需要增加数据索引，使用开源库arrow:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义获取连续时间，start是起始时间，limit是连续的天数,level可以是day,month,year</span></span><br><span class="line"><span class="keyword">import</span> arrow</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_date_range</span><span class="params">(start, limit, level=<span class="string">'month'</span>,format=<span class="string">'YYYY-MM-DD'</span>)</span>:</span></span><br><span class="line">    start = arrow.get(start, format)  </span><br><span class="line">    result=(list(map(<span class="keyword">lambda</span> dt: dt.format(format) , arrow.Arrow.range(level, start, 		   limit=limit))))</span><br><span class="line">    dateparse2 = <span class="keyword">lambda</span> dates:pd.datetime.strptime(dates,<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">    <span class="keyword">return</span> map(dateparse2, result)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 预测从1961-01-01开始，也就是我们训练数据最后一个数据的后一个日期</span><br><span class="line">new_index = get_date_range(&apos;1961-01-01&apos;, forecast_n)</span><br><span class="line">forecast_ARIMA_log = pd.Series(forecast_ARIMA_log, copy=True, index=new_index)</span><br><span class="line">print forecast_ARIMA_log.head()</span><br><span class="line"></span><br><span class="line"># 直接取指数，即可恢复至原数据</span><br><span class="line">forecast_ARIMA = np.exp(forecast_ARIMA_log)</span><br><span class="line">print forecast_ARIMA</span><br><span class="line">plt.plot(ts,label=&apos;Original&apos;,color=&apos;blue&apos;)</span><br><span class="line">plt.plot(forecast_ARIMA, label=&apos;Forcast&apos;,color=&apos;red&apos;)</span><br><span class="line">plt.legend(loc=&apos;best&apos;)</span><br><span class="line">plt.title(&apos;forecast&apos;)</span><br></pre></td></tr></table></figure>
<p><img src="/picture/machine-learning/arima29.jpg" alt="arma"></p>
<p><strong>遗留问题：</strong></p>
<p>如果直接将差分处理的结果传入ARMA模型，再进行forecast预测，如何对预测的结果进行还原至原始序列？</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.analyticsvidhya.com/blog/2016/02/time-series-forecasting-codes-python/" target="_blank" rel="noopener">Complete guide to create a Time Series Forecast (with Codes in Python)</a></p>
<p><a href="http://www.cnblogs.com/foley/p/5582358.html" target="_blank" rel="noopener">时间序列分析</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/picture/wechatpay.JPG" alt="xuetf WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/picture/alipay.JPG" alt="xuetf Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/统计学/" rel="tag"># 统计学</a>
          
            <a href="/tags/时间序列/" rel="tag"># 时间序列</a>
          
            <a href="/tags/人工智能/" rel="tag"># 人工智能</a>
          
            <a href="/tags/ARIMA/" rel="tag"># ARIMA</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/07/ARIMA时间序列模型-二/" rel="next" title="ARIMA时间序列模型(二)">
                <i class="fa fa-chevron-left"></i> ARIMA时间序列模型(二)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/25/生成算法/" rel="prev" title="生成算法">
                生成算法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
         <div id="uyan_frame"></div>
    
  </div>

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars1.githubusercontent.com/u/11912425?v=3&u=11f9f5dc75aaf84f020a06c0b9cb2b6f401c586b&s=400"
               alt="xuetf" />
          <p class="site-author-name" itemprop="name">xuetf</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">69</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">127</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://lsxj615.com/" title="小王子" target="_blank">小王子</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/xuetf/" title="My Github" target="_blank">My Github</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基本概念"><span class="nav-number">1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#p值检验"><span class="nav-number">2.</span> <span class="nav-text">p值检验</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#pandas数据操作"><span class="nav-number">3.</span> <span class="nav-text">pandas数据操作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#稳定性检测"><span class="nav-number">4.</span> <span class="nav-text">稳定性检测</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#滚动统计"><span class="nav-number">4.1.</span> <span class="nav-text">滚动统计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ADF检验"><span class="nav-number">4.2.</span> <span class="nav-text">ADF检验</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#平稳性处理"><span class="nav-number">5.</span> <span class="nav-text">平稳性处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对数变换"><span class="nav-number">5.1.</span> <span class="nav-text">对数变换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#移动平均数"><span class="nav-number">5.2.</span> <span class="nav-text">移动平均数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#差分"><span class="nav-number">5.3.</span> <span class="nav-text">差分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分解"><span class="nav-number">5.4.</span> <span class="nav-text">分解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#时间序列建模"><span class="nav-number">6.</span> <span class="nav-text">时间序列建模</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#平稳性检验"><span class="nav-number">6.1.</span> <span class="nav-text">平稳性检验</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ADF检验-1"><span class="nav-number">6.1.1.</span> <span class="nav-text">ADF检验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自相关图和偏自相关图"><span class="nav-number">6.1.2.</span> <span class="nav-text">自相关图和偏自相关图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参数选择"><span class="nav-number">6.2.</span> <span class="nav-text">参数选择</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#差分阶数选择"><span class="nav-number">6.2.1.</span> <span class="nav-text">差分阶数选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#p和q选择"><span class="nav-number">6.2.2.</span> <span class="nav-text">p和q选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模型"><span class="nav-number">6.3.</span> <span class="nav-text">模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AR-p-模型"><span class="nav-number">6.3.1.</span> <span class="nav-text">AR(p)模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MA-q-模型"><span class="nav-number">6.3.2.</span> <span class="nav-text">MA(q)模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARIMA-p-q-模型"><span class="nav-number">6.3.3.</span> <span class="nav-text">ARIMA(p,q)模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据还原"><span class="nav-number">6.4.</span> <span class="nav-text">数据还原</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预测未来走势"><span class="nav-number">6.5.</span> <span class="nav-text">预测未来走势</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xuetf</span>
</div>




<script type="text/x-mathjax-config">
 MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
 tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
 TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
 messageStyle: "none"
 });
</script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Queue(function() {
 var all = MathJax.Hub.getAllJax(), i;
 for(i=0; i < all.length; i += 1) {
 all[i].SourceElement().parentNode.className += ' has-jax';
 }
 });
</script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Queue(function() {
 var all = MathJax.Hub.getAllJax(), i;
 for(i=0; i < all.length; i += 1) {
 all[i].SourceElement().parentNode.className += ' has-jax';
 }
 });
</script>

<!-- <script charset="utf-8" src="/js/mathjax/2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->

<script charset="utf-8" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>











        

<div class="busuanzi-count">

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  



  
    
  
 
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2122877"></script>
      <!-- UY END -->
  



	





  




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  <!-- custom analytics part create by xiamo -->
<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("DFlRFg5OyISCpmUurUC3Vk4s-gzGzoHsz", "0ayDjXz6ELVOVmPMjLQH3llQ");</script>
<script>
function showTime(Counter) {
  var query = new AV.Query(Counter);
  $(".leancloud_visitors").each(function() {
    var url = $(this).attr("id").trim();
    query.equalTo("url", url);
    query.find({
      success: function(results) {
        if (results.length == 0) {
          var content = '0 ' + $(document.getElementById(url)).text();
          $(document.getElementById(url)).text(content);
          return;
        }
        for (var i = 0; i < results.length; i++) {
          var object = results[i];
          var content = object.get('time') + ' ' + $(document.getElementById(url)).text();
          $(document.getElementById(url)).text(content);
        }
      },
      error: function(object, error) {
        console.log("Error: " + error.code + " " + error.message);
      }
    });

  });
}

function addCount(Counter) {
  var Counter = AV.Object.extend("Counter");
  url = $(".leancloud_visitors").attr('id').trim();
  title = $(".leancloud_visitors").attr('data-flag-title').trim();
  var query = new AV.Query(Counter);
  query.equalTo("url", url);
  query.find({
    success: function(results) {
      if (results.length > 0) {
        var counter = results[0];
        counter.fetchWhenSave(true);
        counter.increment("time");
        counter.save(null, {
          success: function(counter) {
            var content =  counter.get('time') + ' ' + $(document.getElementById(url)).text();
            $(document.getElementById(url)).text(content);
          },
          error: function(counter, error) {
            console.log('Failed to save Visitor num, with error message: ' + error.message);
          }
        });
      } else {
        var newcounter = new Counter();
        newcounter.set("title", title);
        newcounter.set("url", url);
        newcounter.set("time", 1);
        newcounter.save(null, {
          success: function(newcounter) {
              console.log("newcounter.get('time')="+newcounter.get('time'));
            var content = newcounter.get('time') + ' ' + $(document.getElementById(url)).text();
            $(document.getElementById(url)).text(content);
          },
          error: function(newcounter, error) {
            console.log('Failed to create');
          }
        });
      }
    },
    error: function(error) {
      console.log('Error:' + error.code + " " + error.message);
    }
  });
}
$(function() {
  var Counter = AV.Object.extend("Counter");
  if ($('.leancloud_visitors').length == 1) {
    addCount(Counter);
  } else if ($('.post-title-link').length > 1) {
    showTime(Counter);
  }
}); 
</script>
  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  


</body>
</html>
