<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  

  

  
    

    
  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="机器学习,经验风险最小化,方差,偏差," />





  <link rel="alternate" href="/atom.xml" title="蘑菇先生学习记" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="本文与前面不同，主要内容不是算法，而是机器学习的另一部分内容——学习理论。主要包括偏差/方差(Bias/Variance)、经验风险最小化(Empirical Risk Minimization,ERM)、联合界(Union bound)、一致收敛(Uniform Convergence)。
偏差/方差权衡　　回顾一下，当我们讨论线性回归时，我们尝试过使用简单的线性方法，如\(y=\theta">
<meta property="og:type" content="article">
<meta property="og:title" content="Learning Theory">
<meta property="og:url" content="xtf615.com/2017/03/29/Learning-Theory/index.html">
<meta property="og:site_name" content="蘑菇先生学习记">
<meta property="og:description" content="本文与前面不同，主要内容不是算法，而是机器学习的另一部分内容——学习理论。主要包括偏差/方差(Bias/Variance)、经验风险最小化(Empirical Risk Minimization,ERM)、联合界(Union bound)、一致收敛(Uniform Convergence)。
偏差/方差权衡　　回顾一下，当我们讨论线性回归时，我们尝试过使用简单的线性方法，如\(y=\theta">
<meta property="og:image" content="xtf615.com/picture/machine-learning/theory1.jpg">
<meta property="og:image" content="xtf615.com/picture/machine-learning/theory2.jpg">
<meta property="og:image" content="xtf615.com/picture/machine-learning/theory3.jpg">
<meta property="og:image" content="xtf615.com/picture/machine-learning/theory4.jpg">
<meta property="og:updated_time" content="2017-03-30T02:11:25.295Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Learning Theory">
<meta name="twitter:description" content="本文与前面不同，主要内容不是算法，而是机器学习的另一部分内容——学习理论。主要包括偏差/方差(Bias/Variance)、经验风险最小化(Empirical Risk Minimization,ERM)、联合界(Union bound)、一致收敛(Uniform Convergence)。
偏差/方差权衡　　回顾一下，当我们讨论线性回归时，我们尝试过使用简单的线性方法，如\(y=\theta">
<meta name="twitter:image" content="xtf615.com/picture/machine-learning/theory1.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="xtf615.com/2017/03/29/Learning-Theory/"/>





  <title> Learning Theory | 蘑菇先生学习记 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">蘑菇先生学习记</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'WgLy48WeXh1aXsWx1x7L','2.0.0');
</script>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="xtf615.com/2017/03/29/Learning-Theory/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuetf">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/11912425?v=3&u=11f9f5dc75aaf84f020a06c0b9cb2b6f401c586b&s=400">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="蘑菇先生学习记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="蘑菇先生学习记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Learning Theory
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-29T12:59:14+08:00">
                2017-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 阅读量 
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>　　本文与前面不同，主要内容不是算法，而是机器学习的另一部分内容——学习理论。主要包括偏差/方差(Bias/Variance)、经验风险最小化(Empirical Risk Minimization,ERM)、联合界(Union bound)、一致收敛(Uniform Convergence)。</p>
<h1 id="偏差-方差权衡"><a href="#偏差-方差权衡" class="headerlink" title="偏差/方差权衡"></a>偏差/方差权衡</h1><p>　　回顾一下，当我们讨论线性回归时，我们尝试过使用简单的线性方法，如\(y=\theta_0 + \theta_1 x\),也尝试使用更复杂的模型，如多项式\(y=\theta_0+\theta_1 x+…+\theta_5 x^5\)。观察下图：<br><img src="/picture/machine-learning/theory1.jpg" alt="theory"><br>　　以上述回归问题为例，机器学习的目标是从训练集中得到一个模型，使之能对测试集进行分类。这里训练集和测试集都是分布\(\mathcal{D}\)的样本。机器学习的关注点在于模型在测试集上的分类效果，这也称作泛化能力(generalization ability)。如上图，最左边的图用一个线性模型进行拟合，显然即使拥有很多的训练集，该模型在测试集上进行预测的话，仍然存在着很大的误差，这种情况称为欠拟合，对应着高偏差。对于最右边的图，用一个高阶(五阶)去拟合，从数据中得到的模型结构很可能碰巧是该训练集特有的，即尽管五次多项式模型对训练集的拟合不错，但并非是一个好的模型，因为对于训练集以外的数据，该模型不一定能很好得进行预测，即泛化能力不够好，因此仍然存在着很大的泛化误差，这种情况称作过拟合，对应高方差。<br>　　在机器学习中，对偏差和方差的权衡是学习理论重点解决的问题。如果我们的模型太过于简单，只有少量的参数要学习，那么就可能存在高偏差(large bias but small variance)。如果我们的模型太过于复杂，拥有大量的参数，那么就可能存在高方差(large variance but small bias)。在上面的例子中，训练一个二次型的模型(对应中间那幅图)，比训练一个过于简单的一次型模型或过于复杂的五次型模型都好。　　<br><a id="more"></a></p>
<h1 id="经验风险最小化"><a href="#经验风险最小化" class="headerlink" title="经验风险最小化"></a>经验风险最小化</h1><p>　　在这部分我们开始对学习理论进行研究。这部分的研究可以磨练我们的直觉，并学到在不同情况下，更好得应用学习算法的经验法则。我们也会尝试回答一些问题，例如是否可以将偏差/方差的权衡进行形式化表述?这有助于后面对于特征选择方法的学习，也有助于为训练数据选择合适的多项式拟合阶数。其次，在机器学习中，我们对泛化误差格外关注，然而我们的模型是对训练集进行拟合的，训练集拟合表现对泛化误差有什么影响？是否可以将训练集的误差和泛化误差联系在一起。最后一个问题，证明学习算法表现良好是否需要一些条件作为基础？</p>
<h2 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h2><p>　　首先讨论两条引理。<br>　　<strong>联合界定理(The union bound)</strong>:令\(A_1,A_2,…,A_k\)是k个事件，这k个时间可以相互独立也可以不相互独立，我们有:<br>$$P(A_1 \cup A_2 … \cup A_k) \leq P(A_1)+P(A_2)+…+P(A_k)$$<br>　　在概率论中，上述是一个公理。任意事件发生的概率显然小于所有事件各自发生的概率之和。该定理可以使用文氏图(韦恩图)进行非正式的证明。<br>　　<strong>Hoeffding不等式</strong>：令\(Z_1,Z_2,…,Z_m\)为m个独立同分布变量(\(i.i.d\)),它们都服从伯努利分布，即\(P(Z_i=1)=\phi,P(Z_i=0)=1-\phi\),我们使用m个服从\(i.i.d的Z_i\)变量的平均值来估计\(\phi\)，得到:<br>$$\hat{\phi}=\frac{1}{m}\sum_{i=1}^m Z_i$$<br>　　那么Hoeffding不等式的定义即，对于任意的固定数值\(\gamma&gt;0\)，满足：<br>$$P(|\phi-\hat{\phi}|&gt;\gamma) \leq 2exp(-2\gamma^2 m)$$<br>　　这个引理是指,如果我们使用m个满足伯努利分布的随机变量的平均值\(\hat{\phi}\)来估计\(\phi\),那么随着样本数目m的增大，我们对参数的估计\(\hat{\phi}\)会越来越接近真实的\(\phi\)值。上式的概率实际上代表犯错误的概率，即犯错误概率会随样本数目的增大而减小。<br>　　运用上述两条引理，我们可以得出一些重要的学习理论结论。</p>
<h2 id="经验风险"><a href="#经验风险" class="headerlink" title="经验风险"></a>经验风险</h2><p>　　为了简化我们的讨论，我们将注意力集中在二分类问题上，即\(y \in \{0,1\}\)。所有关于二分类问题的讨论同样适用于其它的回归问题或者多分类问题。<br>　　假设给定一个训练集\(S=\{(x^{(i)},y^{(i)});i=1,…,m\}\),样本数量为m，每一个样本都满足独立同分布，且服从分布\(D\),即假设每个样本都是通过该分布生成的。对于一个特定的假设h,我们定义训练误差training error（在学习理论中称作经验风险或经验误差）为：<br>$$\hat{\epsilon}(h)=\frac{1}{m} \sum_{i=1}^m I\{h(x^{(i)}) \not= y^{(i)}\}$$<br>　　\(\hat{\epsilon}(h)\)代表对于<strong>特定</strong>训练集S得到的<strong>估计值</strong>，也可以写作\(\hat{\epsilon}_S(h)\)。我们定义泛化误差generalization error为：<br>$$\epsilon(h)=P(x,y) \sim \mathcal{D}(h(x) \not= y)$$<br>　　泛化误差是针对满足分布的新样本而言，指的是对于满足分布\(\mathcal{D}\)的新样本(x,y),会被h误分类的概率。注意，我们假设训练数据是根据分布\(\mathcal{D}\)得到的，同时，\(\mathcal{D}\)也是测试数据的分布，也就是上式泛化误差中的\(\mathcal{D}\)。这也是PAC假设之一，PAC全称probably approximately correct,是学习理论得以证明所依赖的一个框架和一系列假设，训练集和测试集同分布是其中最重要的一个假设。<br>　　考虑一个线性分类问题，令\(h_\theta(x)=I\{\theta^T x \geq 0\}\),即当\(\theta^T x \geq 0\)时，分类结果为1。一种拟合参数\(\theta\)的方法是最小化训练误差:<br>$$\hat{\theta}=\mathop{argmin}_\limits{\theta} \hat{\epsilon}(h_\theta)$$<br>　　我们称这个过程为经验风险最小化(empirical risk minimization,ERM),根据该学习算法，可以得到假设h的估计，即\(\hat{h}=h_{\hat{\theta}}\)。我们认为ERM是最基本的学习算法，其他算法如逻辑回归等也可以被近似当作ERM。<br>　　在研究学习理论中，我们暂且不考虑假设具体的参数和具体使用的分类器是什么。我们定义一个学习算法的假设空间\(\mathcal{H}\)由所有的决策函数或模型的集合构成。例如对于线性分类问题，有：\(\mathcal{H}=\{h_\theta:h_\theta(x)=I\{\theta^Tx \geq 0\},\theta \in {\mathbb{R}}^{n+1}\}\)。拓展来说，如果我们在学习神经网络，那么\(\mathcal{H}\)就代表一系列可以代表神经网络的决策函数组成。<br>　　在这里，ERM可以认为是在假设空间\(\mathcal{H}\)中寻找使得训练误差最小化的某个假设h.即：<br>$$\hat{h}=\mathop{argmin}_\limits{h \in H} \hat{\epsilon}(h)$$</p>
<h2 id="一致收敛"><a href="#一致收敛" class="headerlink" title="一致收敛"></a>一致收敛</h2><p>　　我们首先考虑有限的假设空间\(\mathcal{H}=\{h_1,…,h_k\}\),假设空间由k个假设组成。因此\(\mathcal{H}\)只是k个由映射函数组成，该映射函数负责从输入空间\(\mathcal{X}\)映射到\(\{0,1\}\)。经验风险最小化就是从这k个函数中选择使得训练误差最小的假设\(\hat{h}\)。<br>　　我们关注的是\(\hat{h}\)在泛化误差上表现,即\(\epsilon(\hat{h})\)。我们的策略包含两个步骤，首先证明，对所有的h，\(\hat{\epsilon}(h)\)都是\(\epsilon(h)\)的可靠估计。接着证明\(\hat{h}\)的泛化误差\(\epsilon(\hat{h})\)存在着一个上界。<br>　　先证明第一个，对所有的h，\(\hat{\epsilon}(h)\)都是\(\epsilon(h)\)的可靠估计。<br>　　从假设空间选取某个特定的\(h_i \in \mathcal{H}\)。考虑伯努利随机变量Z，我们根据分布\(\mathcal{D}\)生成新样本(x,y),即\((x,y) \sim \mathcal{D}\)，再令\(Z=I\{h_i(x) \not= y\}\)，即判断\(h_i\)能否正确分类新样本。同样我们定义\(Z_j=I\{h_i(x^{(j)}) \not= y^{(j)}\}\)，即判断训练集中的样本是否被正确分类。因为训练样本也是根据分布\(\mathcal{D}\)获得的，则Z和\(Z_j\)属于同分布。<br>　　训练误差重写为：<br>$$\hat{\epsilon}(h_i)=\frac{1}{m}\sum_{j=1}^m Z_j$$<br>　　\(\hat{\epsilon}(h_i)\)实际上就是m个服从伯努利分布的随机变量\(Z_j\)的平均值。而\(\epsilon(h_i)\)代表伯努利分布Z的均值。根据Hoeffding不等式，有：<br>$$P(|\epsilon(h_i)-\hat{\epsilon}(h_i)|&gt;\gamma) \leq 2exp(-2\gamma^2 m)$$<br>　　这意味着，对于给定的\(h_i\),当m非常大时，泛化误差和训练误差接近的概率很大，即训练误差\(\hat{\epsilon}(h_i)\)能够很好的估计泛化误差\(\epsilon(h_i)\)。更进一步，我们想证明对于任意的\(h \in \mathcal{H}\),都存在上述结果。为了证明这个结论，我们令\(A_i\)代表\(|\epsilon(h_i)-\hat{\epsilon}(h_i)|&gt;\gamma\)，对于任意给定的\(A_i\),都有：\(P(A_i) \leq 2exp(-2\gamma^2 m)\)。因此使用联合界定义，有：<br>$$P(\exists h \in \mathcal{H}.|\epsilon(h_i)-\hat{\epsilon}(h_i)|&gt;\gamma) = P(A_1 \cup A_2 … \cup A_k) \leq \sum_{i=1}^k P(A_i) \\\\<br>\leq \sum_{i=1}^k 2exp(-2\gamma^2 m) \\\\<br>= 2kexp(-2\gamma^2 m)<br>$$<br>　　同时使用1减去不等式两边有，<br>$$P(\nexists h \in \mathcal{H}.|\epsilon(h_i)-\hat{\epsilon}(h_i)|&gt;\gamma)=P(\forall h \in \mathcal{H}.|\epsilon(h_i)-\hat{\epsilon}(h_i)| \leq \gamma) \geq 1-2kexp(-2\gamma^2m)$$<br>　　上式代表，至少以概率\(1-2kexp(-2\gamma^2m)\)保证,对所有的\(h \in \mathcal{H}\)，都有泛化误差和训练误差的差值不大于\(\gamma\).称作一致收敛定理。<br>　　在一致收敛中，有三个参数,\(m,\gamma\),误差的概率(或称作犯错误的概率),这三个参数是互相关联的，我们可以固定其中两个，来推出第三个，其中固定\(m,\gamma\)求概率上式已经得出。下面依次对另外两种参数关联进行说明。<br>　　第一个，对于给定\(\gamma,\delta &gt; 0\)，需要多少样本，才可以保证至少有\(1-\delta\)的概率，使得泛化误差和训练误差相差在\(\gamma\)的范围内.令\(1-2kexp(-2\gamma^2m) \geq 1-\delta \)可以求出m:<br>$$m \geq \frac{1}{2\gamma^2}log\frac{2k}{\delta}$$<br>　　即当m满足上式时，对任意的\(h \in \mathcal{H}\),都至少有\(1-\delta\)的概率保证\(|\epsilon(h_i)-\hat{\epsilon}(h_i)| \leq \gamma\)，也即犯错误(\(|\epsilon(h_i)-\hat{\epsilon}(h_i)| &gt; \gamma\))的概率至多为\(\delta\)<br>　　这个推论的意义在于，一个模型或算法要达到一个确定的性能时，需要的样本数目为多少。这也称作算法的样本复杂度。上式也表明，达到好的性能，对k的限制只需要对数级别就行，k是假设空间的大小。这个很关键。<br>　　同样的，我们也可以固定m和\(\delta&gt;0\),泛化误差会落在训练误差的什么范围内呢？<br>　　$$|\hat{\epsilon}(h)-\epsilon(h)| \leq \sqrt{\frac{1}{2m} log \frac{2k}{\delta}}$$<br>　　接着证明\(\hat{h}\)的泛化误差\(\epsilon(\hat{h})\)存在着一个上界。也就是考察在一致收敛成立的情况下，我们通过ERM方法得到的假设\(\hat{h}\)的泛化能力到底如何?<br>　　首先定义：<br>$$\hat{h}=\mathop{argmin}_\limits{h \in \mathcal{H}} \hat{\epsilon}(h)$$<br>$$h^{*}=\mathop{argmin}_\limits{h \in \mathcal{H}} \epsilon(h)$$<br>　　\(\hat{h}\)可以理解为在假设空间中，寻找使得训练误差最小的那个假设。\(h^{*}\)可以理解为在假设空间\(\mathcal{H}\)中，寻找使得泛化误差最小的假设。\(h^{*}\)是我们能找到的最好的假设。我们可以将使得训练误差最小的那个假设\(\hat{h}\)和其进行对比,\(\epsilon(\hat{h})\)可以表示训练集上选择使训练误差最小的假设\(\hat{h}\)在泛化误差上的表现。<br>$$\epsilon(\hat{h}) \leq \hat{\epsilon}(\hat{h})+\gamma \\\\<br>\leq \hat{\epsilon}(h^{*}) + \gamma \\\\<br>\leq \epsilon(h^{*}) + 2\gamma<br>$$<br>　　首先是第一个不等式，\(\epsilon(\hat{h})\)是指对于某个特定的假设\(\hat{h}\)的泛化误差,\( \hat{\epsilon}(\hat{h})\)代表对于某个特定的假设\(\hat{h}\)的训练误差。根据一致收敛定理, 在\(1-\delta\)的概率下能保证泛化误差和训练误差相差在\(\gamma\)的范围内时, 即：<br>$$|\epsilon(h_i)-\hat{\epsilon}(h_i)| \leq \gamma$$<br>　　展开不等式：<br>$$-\gamma \leq \epsilon(h_i)-\hat{\epsilon}(h_i) \leq \gamma$$<br>　　根据右半边部分可以得到,\(\epsilon(h_i)\leq \hat{\epsilon}(h_i)+\gamma\),进而推出第一个不等式,这里的\(\hat{h}\)相当于上面的\(h_i\),因为\(h_i\)可以是任意属于假设空间的假设。<br>　　第二个不等式是因为根据上述定义的\(\hat{h}=\mathop{argmin}_\limits{h \in \mathcal{H}} \hat{\epsilon}(h)\),即在训练误差表现上，\(\hat{h}\)是表现最好的，没有任何其他的假设在训练误差上表现会更好，因此\(\hat{\epsilon}(\hat{h}) \leq \hat{\epsilon}(h^{*})\)。<br>　　最后一个不等式，仍然是根据一致收敛定理，根据上述绝对值不等式展开后的左半边部分，有:<br>$$\hat{\epsilon}(h_i) \leq \epsilon(h_i) + \gamma$$<br>　　使用\(h^{*}\)替换\(h_i\),则有：<br>$$\hat{\epsilon}(h^{*}) \leq \epsilon(h^{*}) + \gamma$$<br>　　进而可以推出第三个不等式。<br>　　下面将这些推论综合一下，我们得到一个定理：<br>　　令\(|\mathcal{H}|=k\),给定m和\(\delta&gt;0\),那么至少有\(1-\delta\)的概率能否使下面公式成立:<br>$$\epsilon(\hat{h}) \leq \min_{h \in \mathcal{H}} \epsilon(h) + 2\sqrt{\frac{1}{2m} log \frac{2k}{\delta}}$$<br>　　该定理反映了在训练集上选择使训练误差最小的假设\(\hat{h}\)在泛化误差上的表现(\(\epsilon(\hat{h})\))受模型精确度和复杂度的影响，也就是反映了偏差和方差之间的权衡。可以想象，当选择一个复杂的模型假设时,\(|\mathcal{H}|=k\)会变大 ，导致不等式后的第二项变大，意味着方差变大；但是第一项也会相应的变小，因为使用一个更大的假设空间\(\mathcal{H}\)意味着可供选择的假设变多了，在多的那部分假设中可能存在使误差更小的假设，因此偏差就会变小。故应该选择一个最优值，使得偏差和方差之和最小，才能得到一个好的模型。<br>　　同样，该定理还有另外形式的推论：<br>　　令\(|\mathcal{H}|=k\)，给定\(\gamma,\delta&gt;0\)，那么至少有\(1-\delta\)概率使得\(\epsilon(\hat{h}) \leq \min_\limits{h \in \mathcal{H}} \epsilon(h) + 2\gamma\)成立的前提是：<br>$$m \geq \frac{1}{2\gamma^2} log \frac{2k}{\delta}=O(\frac{1}{\gamma^2}log\frac{k}{\delta})$$</p>
<h1 id="推广无限假设空间"><a href="#推广无限假设空间" class="headerlink" title="推广无限假设空间"></a>推广无限假设空间</h1><p>　　上述讨论的是有限假设空间的情况。我们将其拓展到无限空间。</p>
<h2 id="直观理解"><a href="#直观理解" class="headerlink" title="直观理解"></a>直观理解</h2><p>　　先从一个简单的例子说起。假设我们的假设空间\(\mathcal{H}\)由d个实数参数表示。例如对于逻辑回归，如果有n个特征的话,就有d=n+1(多的一个是截距)个参数。因为计算机通常使用双精度64bit来表示double型数据。因此对于每个参数都有\(2^64\)种不同可能的取值，那么d个参数的话，不同排列组合有，\(2^{64} \times 2^{64} \times …\times 2^{64}\)种，共d个式子，即\(k=2^{64d}\)种不同的假设。为了满足在\(1-\sigma\)概率下，有\(\epsilon(\hat{h}) \leq \epsilon(h^{*})+2\gamma\),则：<br>$$m \geq \frac{1}{2\gamma^2} log \frac{2k}{\delta}=O(\frac{1}{\gamma^2}log\frac{2^{64}}{\delta})=O(\frac{d}{\gamma^2} log \frac{1}{\gamma})=O_{\gamma,\delta}(d)$$<br>　　最后一个O代表对于给定的\(\gamma,\delta\)，即认为为常数的时候，所需要的样本个数应该和参数个数呈线性关系。<br>　　上述证明不够严格，下面进行更正式的表述。(具体证明不给出)</p>
<h2 id="VC维"><a href="#VC维" class="headerlink" title="VC维"></a>VC维</h2><p>　　首先引入VC(Vapnik-Chervonenkis)维的概念。VC维是为了研究学习过程一致收敛的速度和推广性，由统计学理论定义的有关函数集学习性能的一个重要指标。<br>　　具体定义，对一个指示函数集，如果存在H个样本能够被函数集中的函数按所有可能的\(2^H\)种形式分开，则称函数集能够把H个样本打散(分开)；函数集的VC维就是它能打散的最大样本数目H。若对任意数目的样本都有函数能将它们打散,则函数集的VC维是无穷大，它可以将任意多样本的任意标注情况精确分开，即在训练集上达到100%的分类正确率。<br>　　我们可以看一下2维空间，对于3个样本而言：<br><img src="/picture/machine-learning/theory2.jpg" alt="theory"><br>　　共用8种可能(\(2^3\),任意一个样本可以在直线任意一侧)。可以发现都可以很好的分开，只要存在一种放置该8种可能的方式即可(例如如果选择同一直线的方式就不能打散，但是存在其他种不再同一直线上的8种方式可以进行打散)。我们再观察4个样本，都不能同时对\(2^4=16\)种标注进行打散，即不是所有的标注形式，都能找到一个假设来分散，因此VC维在二维线性分类器上等于3。推广至<br>维线性分类器上，VC维d=n+1。<br>　　实际上对于无限假设空间，我们令该假设空间的VC维为d，即\(d=VC(\mathcal{H})\)。我们可以得到如下结论，在\(1-\delta\)概率下,对于所有的\(h \in \mathcal{H}\),都有：<br>$$|\epsilon(h)-\hat{\epsilon}(h)| \leq O\left(\sqrt{\frac{d}{m} log \frac{m}{d} + \frac{1}{m} log \frac{1}{\delta}}\right)$$<br>　　同样，我们可以推出，在\(1-\delta\)概率下：<br>$$\epsilon(\hat{h}) \leq \epsilon(h^{*}) + O\left(\sqrt{\frac{d}{m} log \frac{m}{d} + \frac{1}{m} log \frac{1}{\delta}}\right)$$<br>　　换句话说，如果某个假设空间有有限的VC维，那么当m变大的时候，一致收敛会发生。<br>　　进而得出m大小的推论，对于给定的\(\gamma,\delta&gt;0\),在\(1-\delta\)概率下保证\(\epsilon(\hat{h}) \leq \epsilon(h^{*})+2\gamma\)，则:<br>$$m=O_{\gamma,\delta}(d)$$<br>　　最后得出结论，对于一个目标是使训练误差最小的算法而言，需要的样本数量和假设空间的VC维大小呈线性关系，实际上VC维可以理解为假设空间参数的数目,即对大多数模型而言，VC维和模型参数的数目呈正比关系。</p>
<h2 id="拓展：VC维解释SVM"><a href="#拓展：VC维解释SVM" class="headerlink" title="拓展：VC维解释SVM"></a>拓展：VC维解释SVM</h2><p>　　根据上一篇文章我们知道，SVM通过核函数将数据映射到高维空间，模型复杂度增加，那么相应的，其VC维应该变大，要达到较好的效果所需的数据应该增大才对。但SVM只在原数据上就达到了比其他模型更优的结果，为什么呢？<br>　　虽然SVM将数据映射到高维空间，但是其仍然有最大间隔分类器的假设，而对于最大间隔分类器来说，<strong>其VC维并不依赖X的维度</strong>.对于最小间隔为\(\gamma\)的分类器而言，令\(||x^{(i)}||_2 \leq R\),即采样点在半径为R的圆内。那么:<br>$$VC(H) \leq \left \lceil \frac{R^2}{4\gamma^2} \right\rceil + 1$$<br>　　SVM算法会自动寻找一个具有较小VC维的假设，这样反而降低了VC维，使得原来的数据量就相对足够充分(\(m \propto O(d)\))，因此不影响模型的效果。</p>
<h1 id="ERM的直观意义"><a href="#ERM的直观意义" class="headerlink" title="ERM的直观意义"></a>ERM的直观意义</h1><p>　　ERM即经验风险最小化，有公式：<br>$$\hat{\epsilon}(h)=\frac{1}{m} \sum_{i=1}^m I\{h(x^{(i)}) \not= y^{(i)}\}$$<br>　　我们以单个样本为例，其误差函数为\(I\{h(x^{(i)}) \not= y^{(i)}\}\),很显然，这是一个非凸函数，使用机器学习的方法并不能很好的对其进行优化。因而产生了一些算法对该误差函数进行凸性近似，以期能够更好的优化，以svm和logistic为例，如图2所示：<br><img src="/picture/machine-learning/theory3.jpg" alt="theory"><br>　　如上图，logistic模型采用极大似然估计方法，它尝试令负的对数似然最小，即，\(-log P(y^{(i)}|x^{(i)};\theta)\),因而如图2中的曲线所示。SVM使用的是大间隔概念，即不仅仅考虑\(\theta^T x\)大于0,更严格的跟1或者-1比较。可以根据下图理解：<br><img src="/picture/machine-learning/theory4.jpg" alt="theory"><br>　　上图可以令负样本的\(y^{(i)}=-1\),这样就可以利用函数间隔概念统一化。<br>　　因此虽然logistic和svm都不是直接的ERM算法，但基于对ERM的近似而产生，因而可见，ERM的一致性定理在实际中的威力。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://open.163.com/special/opencourse/machinelearning.html" target="_blank" rel="external">斯坦福大学机器学习视频教程</a><br><a href="http://www.flickering.cn/machine_learning/2015/04/vc%E7%BB%B4%E7%9A%84%E6%9D%A5%E9%BE%99%E5%8E%BB%E8%84%89/" target="_blank" rel="external">VC维的来龙去脉</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/picture/wechatpay.JPG" alt="xuetf WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/picture/alipay.JPG" alt="xuetf Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/机器学习/" rel="tag"># 机器学习</a>
          
            <a href="/tags/经验风险最小化/" rel="tag"># 经验风险最小化</a>
          
            <a href="/tags/方差/" rel="tag"># 方差</a>
          
            <a href="/tags/偏差/" rel="tag"># 偏差</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/28/SVM支持向量机/" rel="next" title="SVM支持向量机">
                <i class="fa fa-chevron-left"></i> SVM支持向量机
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/01/ml-advice/" rel="prev" title="Advice for applying Machine Learning">
                Advice for applying Machine Learning <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
         <div id="uyan_frame"></div>
    
  </div>

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars1.githubusercontent.com/u/11912425?v=3&u=11f9f5dc75aaf84f020a06c0b9cb2b6f401c586b&s=400"
               alt="xuetf" />
          <p class="site-author-name" itemprop="name">xuetf</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">36</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">72</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://lsxj615.com/" title="小王子" target="_blank">小王子</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/xuetf/" title="My Github" target="_blank">My Github</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#偏差-方差权衡"><span class="nav-number">1.</span> <span class="nav-text">偏差/方差权衡</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#经验风险最小化"><span class="nav-number">2.</span> <span class="nav-text">经验风险最小化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引理"><span class="nav-number">2.1.</span> <span class="nav-text">引理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#经验风险"><span class="nav-number">2.2.</span> <span class="nav-text">经验风险</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一致收敛"><span class="nav-number">2.3.</span> <span class="nav-text">一致收敛</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#推广无限假设空间"><span class="nav-number">3.</span> <span class="nav-text">推广无限假设空间</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#直观理解"><span class="nav-number">3.1.</span> <span class="nav-text">直观理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VC维"><span class="nav-number">3.2.</span> <span class="nav-text">VC维</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拓展：VC维解释SVM"><span class="nav-number">3.3.</span> <span class="nav-text">拓展：VC维解释SVM</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ERM的直观意义"><span class="nav-number">4.</span> <span class="nav-text">ERM的直观意义</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">5.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xuetf</span>
</div>




<script type="text/x-mathjax-config">
 MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
 tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
 TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
 messageStyle: "none"
 });
</script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Queue(function() {
 var all = MathJax.Hub.getAllJax(), i;
 for(i=0; i < all.length; i += 1) {
 all[i].SourceElement().parentNode.className += ' has-jax';
 }
 });
</script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Queue(function() {
 var all = MathJax.Hub.getAllJax(), i;
 for(i=0; i < all.length; i += 1) {
 all[i].SourceElement().parentNode.className += ' has-jax';
 }
 });
</script>
<script charset="utf-8" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  



  
    
  
 
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2122877"></script>
      <!-- UY END -->
  



	





  




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  <!-- custom analytics part create by xiamo -->
<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("DFlRFg5OyISCpmUurUC3Vk4s-gzGzoHsz", "0ayDjXz6ELVOVmPMjLQH3llQ");</script>
<script>
function showTime(Counter) {
  var query = new AV.Query(Counter);
  $(".leancloud_visitors").each(function() {
    var url = $(this).attr("id").trim();
    query.equalTo("url", url);
    query.find({
      success: function(results) {
        if (results.length == 0) {
          var content = '0 ' + $(document.getElementById(url)).text();
          $(document.getElementById(url)).text(content);
          return;
        }
        for (var i = 0; i < results.length; i++) {
          var object = results[i];
          var content = object.get('time') + ' ' + $(document.getElementById(url)).text();
          $(document.getElementById(url)).text(content);
        }
      },
      error: function(object, error) {
        console.log("Error: " + error.code + " " + error.message);
      }
    });

  });
}

function addCount(Counter) {
  var Counter = AV.Object.extend("Counter");
  url = $(".leancloud_visitors").attr('id').trim();
  title = $(".leancloud_visitors").attr('data-flag-title').trim();
  var query = new AV.Query(Counter);
  query.equalTo("url", url);
  query.find({
    success: function(results) {
      if (results.length > 0) {
        var counter = results[0];
        counter.fetchWhenSave(true);
        counter.increment("time");
        counter.save(null, {
          success: function(counter) {
            var content =  counter.get('time') + ' ' + $(document.getElementById(url)).text();
            $(document.getElementById(url)).text(content);
          },
          error: function(counter, error) {
            console.log('Failed to save Visitor num, with error message: ' + error.message);
          }
        });
      } else {
        var newcounter = new Counter();
        newcounter.set("title", title);
        newcounter.set("url", url);
        newcounter.set("time", 1);
        newcounter.save(null, {
          success: function(newcounter) {
              console.log("newcounter.get('time')="+newcounter.get('time'));
            var content = newcounter.get('time') + ' ' + $(document.getElementById(url)).text();
            $(document.getElementById(url)).text(content);
          },
          error: function(newcounter, error) {
            console.log('Failed to create');
          }
        });
      }
    },
    error: function(error) {
      console.log('Error:' + error.code + " " + error.message);
    }
  });
}
$(function() {
  var Counter = AV.Object.extend("Counter");
  if ($('.leancloud_visitors').length == 1) {
    addCount(Counter);
  } else if ($('.post-title-link').length > 1) {
    showTime(Counter);
  }
}); 
</script>
  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  


</body>
</html>
