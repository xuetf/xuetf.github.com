---
title: 线性回归
date: 2017-02-09 22:27:47
tags: [机器学习,线性回归,广义线性模型,梯度下降]
categories: 机器学习
---
# 模型表示

## 房价预测例子

  让我们通过一个例子来开始：这个例子是预测住房价格的，我们要使用一个数据集，数据集包含俄勒冈州波特兰市的住房价格。在这里，我要根据不同房屋尺寸所售出的价格，画出我的数据集。比方说，如果你朋友的房子是1250平方尺大小，你要告诉他们这房子能卖多少钱。那么，你可以做的一件事就是构建一个模型，也许是条直线，从这个数据模型上来看，也许你可以告诉你的朋友，他能以大约 220000(美元)左右的价格卖掉这个房子。这就是监督学习算法的一个例子
![house_price][1]
   它被称作监督学习是因为对于每个数据来说，我们给出了“正确的答案”，即告诉我们：根据我们的数据来说，房子实际的价格是多少，而且，更具体来说，这是一个回归问题。回归一词指的是，我们根据之前的数据预测出一个准确的输出值，对于这个例子就是价格，同时，还有另一种最常见的监督学习方式，叫做分类问题，当我们想要预测离散的输出值，例如，我们正在寻找癌症肿瘤，并想要确定肿瘤是良性的还是恶性的，这就是 0/1离散输出的问题。更进一步来说，在监督学习中我们有一个数据集，这个数据集被称训练集。下图是房价预测数据格式：
  ![train_set_representation][2] 
<!--more-->  
## 标记
我们将要用来描述这个回归问题的标记如下:
    m代表训练集中实例的数量
    x代表特征/输入变量
    y代表目标变量/输出变量
    (x,y)代表训练集中的实例
    \\((x^{(i)},y^{(i)})\\) 代表第i个观察实例
    h代表学习算法的解决方案或函数也称为假设(hypothesis)
![supervised_learning][3] 
  这就是一个监督学习算法的工作方式，我们可以看到这里有我们的训练集里房屋价格我们把它喂给我们的学习算法，学习算法的工作了，然后输出一个函数，通常表示为小写h表示。h代表   hypothesis(假设)，h表示一个函数，输入是房屋尺寸大小，就像你朋友想出售的房屋，因此h根据输入的x值来得出y值，y值对应房子的价格因此，h是一个从x到y的函数映射。
   我将选择最初的使用规则h代表hypothesis，因而，要解决房价预测问题，我们实际上是要将训练集“喂”给我们的学习算法，进而学习得到一个假设 h，然后将我们要预测的房屋的尺寸作为输入变量输入给h，预测出该房屋的交易价格作为输出变量输出为结果。那么，对于我们的房价预测问题，我们该如何表达h？
   一种可能的表达方式为：\\(h_θ(x)=θ_0+θ_1x\\)，因为只含有一个特征/输入变量，因此这样的问题叫作单变量线性回归问题。

# 代价函数
我们将定义代价函数的概念，这有助于我们弄清楚如何把最有可能的直线与我们的数据相拟合。如图： 
![cost_function][4]
在线性回归中我们有一个像这样的训练集，m代表了训练样本的数量，比如m=47.而我们的假设函数，也就是用来进行预测的函数，是这样的线性函数形式：\\(h_θ(x)=θ_0+θ_1x\\)。接下来我们会引入一些术语我们现在要做的便是为我们的模型选择合适的参数（parameters）θ0和θ1，在房价问题这个例子中便是直线的斜率和在  y轴上的截距。我们选择的参数决定了我们得到的直线相对于我们的训练集的准确程度，模型所预测的值与训练集中实际值之间的差距（下图中蓝线所指）就是建模误差（modeling error）。
![modeling_error][5]
我们的目标便是选择出可以使得建模误差的平方和能够最小的模型参数。即使得代价函数最小：
$$J(\theta_{0},\theta_{1})=\frac{1}{2m}\sum_{i=1}^m\left(h_{\theta}(x^{(i)})-y^{(i)}\right)^2$$
我们绘制一个等高线图，三个坐标分别为 \\(θ_0\\) 和\\(θ_1\\) 和 \\(J(θ_0,θ_1)\\) ：
![contour][6]
可以看出在三维空间中存在一个使得 \\(J(θ_0,θ_1)\\) 最小的点.
代价函数也被称作平方误差函数，有时也被称为平方误差代价函数。我们之所以要求出
误差的平方和，是因为误差平方代价函数，对于大多数问题，特别是回归问题，都是一个合
理的选择。还有其他的代价函数也能很好地发挥作用，但是平方误差代价函数可能是解决回
归问题最常用的手段了。

## 代价函数的理解（1）
### Hypothesis:
$$h_\theta(x)=\theta_0+\theta_1x$$
### Parameters:
$$\theta_0,  \theta_1$$
### Cost Function:
$$J(\theta_{0},\theta_{1})=\frac{1}{2m}\sum_{i=1}^m\left(h_{\theta}(x^{(i)})-y^{(i)}\right)^2$$
### Goal: 
$$\min_{\theta_0,\theta_1}J(\theta_0,\theta_1)$$
![mini][7]
如上图所示，左图为 \\(\theta_0=0,\theta_1=0\\) 时的代价,右图为 \\(\theta_0=0\\),代价函数随 \\(\theta_1\\) 变化的情况。可以看出当 \\(\theta_1=1\\) 时，代价损失最低。

## 代价函数的理解（2）
![contour2][8]
如图是代价函数的样子，等高线图，可以看出在三维空间中存在一个使得 \\(J(θ_0,θ_1)\\) 最小的点。
![contour3][9]
上图右边图形为三维图的二维等高线图。
通过这些图形，能更好地理解这些代价函数J所表达的值是什么样的，它们对应的假设是什么样的，以及什么样的假设对应的点，更接近于代价函数J的最小值。
当然，我们真正需要的是一种有效的算法，能够自动地找出这些使代价函数J取最小值的参数\\(θ_0\\)和 \\(θ_1\\)来。
我们也不希望编个程序把这些点画出来，然后人工的方法来读出这些点的数值，这很明显不是一个好办法。我们会遇到更复杂、更高维度、更多参数的情况，而这些情况是很难画出图的，因此更无法将其可视化，因此我们真正需要的是编写程序来找出这些最小化代价函数的 \\(θ_0\\)和 \\(θ_1\\)的值.

# 梯度下降Gradient Descent
梯度下降是一个用来求函数最小值的算法，我们将使用梯度下降算法来求出代价函数\\(J(θ_0,θ_1)\\)的最小值。
梯度下降背后的思想是：开始时我们随机选择一个参数的组合 \\((θ_0,θ_1,...,θ_n)\\) ，计算代价
函数，然后我们寻找下一个能让代价函数值下降最多的参数组合。我们持续这么做直到到到一个局部最小值（local minimum），因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值（global minimum），选择不同的初始参数组合，可能会找到不同的局部最小值。
![hill][10]
想象一下你正站立在山的这一点上，站立在你想象的公园这座红色山上，在梯度下降算法中，我们要做的就是旋转 360度，看看我们的周围，并问自己要在某个方向上，用小碎步尽快下山。这些小碎步需要朝什么方向？如果我们站在山坡上的这一点，你看一下周围，你会发现最佳的下山方向，你再看看周围，然后再一次想想，我应该从什么方向迈着小碎步下山？然后你按照自己的判断又迈出一步，重复上面的步骤，从这个新的点，你环顾四周，并决定从什么方向将会最快下山，然后又迈进了一小步，并依此类推，直到你接近局部最低点的位置。
批量梯度下降（batch gradient descent）算法的公式为：
**repeat until convergence**{
   $$\theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1) \quad(for \\ j = 0\\ and\\ j = 1)$$
}
其中 \\(\alpha\\)是学习率（learning rate），它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大，在批量梯度下降中，我们每一次都同时让所有的参数减去学习速
率乘以代价函数的导数。
![gradient][11]
在梯度下降算法中，还有一个更微妙的问题，梯度下降中，我们要更新\\(θ_0\\)和 \\(θ_1\\)，当j=0和j=1时，会产生更新，所以你将更新 \\(J_{θ_0}\\)和\\(J_{θ_0}\\)。实现梯度下降算法的微妙之处是，在这个表达式中，如果你要更新这个等式，你需要同时更新\\(θ_0\\)和 \\(θ_1\\).
让我进一步阐述这个过程：
$$temp_0:=\theta_0-\alpha\frac{\partial}{\partial\theta_0}J(\theta_0,\theta_1)\\\\temp_1:=\theta_1-\alpha\frac{\partial}{\partial\theta_1}J(\theta_0,\theta_1) \\\\ \theta_0:=temp_0 \\\\ \theta_1:=temp_1$$
在梯度下降算法中，这是正确实现同时更新的方法。我不打算解释为什么你需要同时更新，同时更新是梯度下降中的一种常用方法。我们之后会讲到，同步更新是更自然的实现方法。当人们谈到梯度下降时，他们的意思就是同步更新。

## 梯度下降理解
$$\theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1)$$
描述：对θ赋值，使得J(θ)按梯度下降最快方向进行，一直迭代下去，最终得到局部最小值。其中 α是学习率（learning  rate），它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大。
![gradient][12] 
对于这个问题，求导的目的，基本上可以说取这个红点的切线，就是这样一条红色的直线，刚好与函数相切于这一点，让我们看看这条红色直线的斜率，就是这条刚好与函数曲线相切的这条直线，这条直线的斜率正好是这个三角形的高度除以这个水平长度，现在，这条线有一个正斜率，也就是说它有正导数，因此，我得到的新的\\(θ_1\\)，\\(θ_1\\)更新后等于\\(θ_1\\)减去一个正数乘以 α。这就是我梯度下降法的更新规则：\\(\theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1)\\)
让我们来看看如果 α太小或α太大会出现什么情况：

 - 如果α太小了，即我的学习速率太小，结果就是只能这样像小宝宝一样一点点地挪动，去努力接近最低点，这样就需要很多步才能到达最低点，所以如果 α太小的话，可能会很慢因为它会一点点挪动，它会需要很多步才能到达全局最低点。
 - 如果 α太大，那么梯度下降法可能会越过最低点，甚至可能无法收敛，下一次迭代又移动了一大步，越过一次，又越过一次，一次次越过最低点，直到你发现实际上离最低点越来越远，所以，如果 α太大，它会导致无法收敛，甚至发散。

现在，还有一个问题，**如果我们预先把\\(θ_1\\)放在一个局部的最低点，你认为下一步梯度下降法会怎样工作？**
假设你将\\(θ_1\\)初始化在局部最低点，在这儿，它已经在一个局部的最优处或局部最低点。
结果是局部最优点的导数将等于零，因为它是那条切线的斜率。这意味着你已经在局部最优点，它使得\\(θ_1\\)不再改变，也就是新的\\(θ_1\\)等于原来的\\(θ_1\\)，因此，如果你的参数已经处于局部最低点，那么梯度下降法更新其实什么都没做，它不会改变参数的值。这也解释了为什么即使学习速率α保持不变时，梯度下降也可以收敛到局部最低点。
我们来看一个例子，这是代价函数 J(θ)。
![gradient][13] 
我想找到它的最小值，首先初始化我的梯度下降算法，在那个品红色的点初始化，如果我更新一步梯度下降，也许它会带我到这个点，因为这个点的导数是相当陡的。现在，在这个绿色的点，如果我再更新一步，你会发现我的导数，也即斜率，是没那么陡的。随着我接近最低点，我的导数越来越接近零，所以，梯度下降一步后，新的导数会变小一点点。然后我想再梯度下降一步，在这个绿点，我自然会用一个稍微跟刚才在那个品红点时比，再小一点的一步，到了新的红色点，更接近全局最低点了，因此这点的导数会比在绿点时更小。所以，我再进行一步梯度下降时，我的导数项是更小的，\\(θ_1\\)更新的幅度就会更小。所以随着梯度下降法的运行，你移动的幅度会自动变得越来越小，直到最终移动幅度非常小，你会发现，已经收敛到局部极小值。
回顾一下，在梯度下降法中，当我们接近局部最低点时，梯度下降法会自动采取更小的幅度，这是因为当我们接近局部最低点时，很显然在局部最低时导数等于零，所以当我们接近局部最低时，导数值会自动变得越来越小，所以梯度下降将自动采取较小的幅度，这就是梯度下降的做法。所以实际上没有必要再另外减小 α。这就是梯度下降算法，你可以用它来最小化任何代价函数 J，不只是线性回归中的代价函数J。

## 梯度下降的线性回归
梯度下降是很常用的算法，它不仅被用在线性回归上和线性回归模型、平方误差代价函数。接下来我们要将梯度下降和代价函数结合。我们将用到此算法，并将其应用于具体的拟合直线的线性回归算法里。
梯度下降算法和线性回归算法比较如图：
![gradient][14]
对我们之前的线性回归问题运用梯度下降法，关键在于求出代价函数的导数，即：
$$\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1)=\frac{\partial}{\partial\theta_j}\left(\frac{1}{2m}\sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})^2\right)$$ 
 - j = 0时, 
$$\frac{\partial}{\partial\theta_0}J(\theta_0,\theta_1)=\frac{1}{m}\sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})$$
 - j = 1时，
$$\frac{\partial}{\partial\theta_1}J(\theta_0,\theta_1)=\frac{1}{m}\sum_{i=1}^m((h_{\theta}(x^{(i)})-y^{(i)})\*x^{(i)})$$
则算法改写成：
**repeat until convergence**{
   $$\theta_0:=\theta_0-\alpha\frac{1}{m}\sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)}) \\\\ \theta_1:=\theta_1-\alpha\frac{1}{m}\sum_{i=1}^m((h_{\theta}(x^{(i)})-y^{(i)})*x^{(i)})$$
}
  我们刚刚使用的算法，有时也称为批量梯度下降。实际上，在机器学习中，通常不太会给算法起名字，但这个名字”批量梯度下降”，指的是在梯度下降的每一步中，我们都用到了所有的训练样本，在梯度下降中，在计算微分求导项时，我们需要进行求和运算，所以，在每一个单独的梯度下降中，我们最终都要计算这样一个东西，这个项需要对所有m个训练样本求和。因此，批量梯度下降法这个名字说明了我们需要考虑所有这一"批"训练样本，而事实上，有时也有其他类型的梯度下降法，不是这种"批量"型的，不考虑整个的训练集，而是每次只关注训练集中的一些小的子集。
  有一种计算代价函数J最小值的数值解法，不需要梯度下降这种迭代算法。它可以在不需要多步梯度下降的情况下，也能解出代价函数J的最小值，这是另一种称为正规方程(normal equations)的方法。实际上在数据量较大的情况下，梯度下降法比正规方程要更适用一些。

# 多变量线性回归
## 多维特征
目前为止，我们探讨了单变量/特征的回归模型，现在我们对房价模型增加更多的特征，
例如房间数楼层等，构成一个含有多个变量的模型，模型中的特征为\\((x_1,x_2,...,x_n)\\)
![multiple feature][15]
增添更多特征后，我们引入一系列新的注释：
n代表特征的数量
\\(x^{(i)}\\) 代表第i个训练实例，是特征矩阵中的第i行，是一个向量（vector）。例如上图中：$$x^{(2)}=\begin{bmatrix} 1416 \\\\ 3 \\\\ 2 \\\\ 40\end{bmatrix}$$

\\(x_j^{(i)}\\) 代表特征矩阵中第i行的第j个特征，也就是第i个训练实例的第j个特征。例如上图中， \\(x_3^{(2)}=2\\)
支持多变量的假设h表示为：
$$h_\theta(x)=\theta_0+\theta_1x_1+\theta_2x_2+...+\theta_nx_n$$
这个公式中有 n+1个参数和n个变量，为了使得公式能够简化一些，引入 \\(x_0=1\\)， 此时模型中的参数是一个n+1维的向量，任何一个训练实例也都是n+1维的向量，特征矩阵\\(X\\)的维度是m*(n+1)。因此公式可以简化为：
$$h_{\theta}(x)=\theta^TX$$ 

## 多变量梯度下降
与单变量线性回归类似，在多变量线性回归中，我们也构建一个代价函数，则这个代价
函数是所有建模误差的平方和，即：
$$J(\theta_{0},\theta_{1}...,\theta_{n})=\frac{1}{2m}\sum_{i=1}^m\left(h_{\theta}(x^{(i)})-y^{(i)}\right)^2$$
其中 \\(h_\theta(x)=\theta_0x_0+\theta_1x_1+\theta_2x_2+…+\theta_nx_n\\)
我们的目标和单变量线性回归问题中一样，是要找出使得代价函数最小的一系列参数。
多变量线性回归的批量梯度下降算法为：
**repeat until convergence**{
   $$\theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1,...,\theta_n)$$
}
即：
**repeat until convergence**{
   $$\theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}\left(\frac{1}{2m}\sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})^2\right)$$
}
求导后得到：

**repeat until convergence**{
   $$\theta_j:=\theta_j-\alpha\frac{1}{m}\sum_{i=1}^m((h_{\theta}(x^{(i)})-y^{(i)})*x_j^{(i)}) \\\\ (simultaneously \\ update \\ \theta_j \\ for \\ j=0,1,2,...,n)$$
}
我们开始随机选择一系列的参数值，计算所有的预测结果后，再给所有的参数一个新的值，如此循环直到收敛。

## 梯度下降实践——特征缩放
在我们面对多维特征问题的时候，我们要保证这些特征都具有相近的尺度，这将帮助梯度下降算法更快地收敛。
以房价问题为例，假设我们使用两个特征，房屋的尺寸和房间的数量，尺寸的值为   0-2000平方英尺，而房间数量的值则是0-5，以两个参数分别为横纵坐标，绘制代价函数的等高线图能，看出图像会显得很扁，梯度下降算法需要非常多次的迭代才能收敛。
![feature_scale][16]
解决的方法是尝试将所有特征的尺度都尽量缩放到-1到1之间。如图： 
![feature_scale][17]
最简单的方法是令：
$$x_n = \frac{x_n-\mu_n}{S_n} \\\\ 其中, \mu_n是平均值，S_n是标准差$$
## 梯度下降实践——学习率
梯度下降算法收敛所需要的迭代次数根据模型的不同而不同，我们不能提前预知，我们可以绘制迭代次数和代价函数的图表来观测算法在何时趋于收敛。
![learn_rate][18]
梯度下降算法的每次迭代受到学习率的影响，如果学习率 α过小，则达到收敛所需的迭代次数会非常高；如果学习率 α过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。通常可以考虑尝试些学习率：\\(α=0.01，0.03，0.1，0.3，1，3，10\\)
## 特征与多项式回归
如房价预测问题，
$$h_\theta(x)=\theta_0+\theta_1\*frontage+\theta_2\*depth\\\\ x_1=frontage(临街宽度),x_2=depth(纵向深度) \\\\ x=frontage*depth=area(面积) ， 则：h_\theta(x)=\theta_0+\theta_1x$$
线性回归并不适用于所有数据，有时我们需要曲线来适应我们的数据，比如一个二次方模型：
$$h_\theta(x)=\theta_0+\theta_1x+\theta_2x_2^2$$
或者三次方模型：
$$h_\theta(x)=\theta_0+\theta_1x+\theta_2x_2^2+\theta_3x_3^3$$
![polynomial_regression][19]
通常我们需要先观察数据然后再决定准备尝试怎样的模型。另外，我们可以令：
$$x_2=x_2^2 \\\\ x_3=x_3^2$$
从而将模型转化为线性回归模型。
根据函数图形特性，我们还可以使：
$$h_\theta(x)=\theta_0+\theta_1(size)+\theta_2(size)^2
\\\\ 或者 \\\\
h_\theta(x)=\theta_0+\theta_1(size)+\theta_2\sqrt{(size)}$$
注：如果我们采用多项式回归模型，在运行梯度下降算法前，特征缩放非常有必要。

## 正规方程
到目前为止，我们都在使用梯度下降算法，但是对于某些线性回归问题，正规方程方法正规方程是通过求解下面的方程来找出使得代价函数最小的参数的是更好的解决方案。
正规方程是通过求解下面的方程来找出使得代价函数最小的参数的：
$$\frac{\partial}{\partial\theta_j}J(\theta_j)=0$$
假设我们的训练集特征矩阵为:\\(X\\)（包含 \\(x_0=1\\) ）,并且我们的训练集结果为向量   y，则利用正规方程解出向量:
$$\theta=\left(X^TX\right)^{-1}X^Ty \\\\
设矩阵A=X^TX，则：(X^TX)^{-1}=A^{-1} \\\\
上标T代表矩阵转置，-1代表矩阵的逆。$$
### 示例：
![normal_example][20]
<table>  
    <tr>  
        <td>X(0)</td> <td>X(1)</td> <td>X(2)</td> <td>X(3)</td> <td>X(4)</td><td>y</td>
    </tr>  
    <tr>  
        <td>1</td><td>2104</td> <td>5</td> <td>1</td> <td>45</td> <td>460</td>
    </tr>  
    <tr>  
        <td>1</td><td>1416</td> <td>3</td> <td>2</td> <td>40</td> <td>232</td>
    </tr>
    <tr>  
        <td>1</td><td>1534</td> <td>3</td> <td>2</td> <td>30</td> <td>315</td>
    </tr>
    <tr>  
        <td>1</td><td>852</td> <td>2</td> <td>1</td> <td>36</td> <td>178</td>
    </tr>
</table>  
再运用正规方程求解参数：
![normal_example][21]
注：**对于那些不可逆的矩阵**（通常是因为特征之间不独立，如同时包含英尺为单位的尺寸和米为单位的尺寸两个特征，也有可能是特征数量大于训练集的数量），正规方程方法是不能用的。
 |编号|说明|国外|   
### 梯度下降和正规方程比较：
<table>  
    <tr>  
        <td>**梯度下降**</td> <td>**正规方程**</td> 
    </tr>  
    <tr>  
        <td>需要选择学习率</td><td>不需要</td>
    </tr>  
    <tr>  
        <td>需要多次迭代</td><td>一次运算得出</td>
    </tr>
    <tr>  
        <td>当特征数量 n大时也能较好适用</td> <td>需要计算 \\((X^TX)^{-1}\\) 如果特征数量n较大则运算代价大，因为矩阵逆的计算时间复杂度为 \\(O(n^3)\\)，通常来说当n小于10000时还是可以接受的</td> 
    </tr>
    <tr>  
        <td>适用于各种类型的模型</td><td>只适用于线性模型，不适合逻辑回归模型等其他模型</td>
    </tr>
</table>
总结一下，只要特征变量的数目并不大，标准方程是一个很好的计算参数  θ的替代方法。具体地说，只要特征变量数量小于一万，我通常使用标准方程法，而不使用梯度下降法。随着学习算法越来越复杂，例如，当我们讲到分类算法，像逻辑回归算法，我们会看到，实际上对于那些算法，并不能使用标准方程法。对于那些更复杂的学习算法，我们将不得不仍然使用梯度下降法。因此，梯度下降法是一个非常有用的算法，可以用在有大量特征变量的线性回归问题。
### 正规方程之不可逆性
我们要讲的问题如下：
$$\theta=\left(X^TX\right)^{-1}X^Ty$$
对于矩阵，\\(X^TX\\) 不可逆的情况怎么解决？
如果你懂一点线性代数的知识，你或许会知道，有些矩阵可逆，而有些矩阵不可逆。我们称那些不可逆矩阵为奇异或退化矩阵。问题的重点在于 X'X的不可逆的问题很少发生。

 - 特征值存在线性关联。
例如，在预测住房价格时，如果x1是以英尺为尺寸规格计算的房子，x2是以平方米为尺寸规格计算的房子，同时，你也知道 1米等于3.28英尺(四舍五入到两位小数)，这样，你的这两个特征值将始终满足约束：\\(x_1=x_2*(3.28)\\)。
 - 大量的特征
第二个原因是，在你想用大量的特征值，尝试实践你的学习算法的时候，可能会导致矩阵 \\(X^TX\\)的结果是不可逆的。
具体地说，在 m小于或等于n的时候，例如，有m等于10个的训练样本,n等于100的特征数量。要找到适合的(n+1)维参数矢量\\(θ\\)，这将会变成一个101维的矢量，尝试从10个训练样本中找到满足101个参数的值，这工作可能会让你花上一阵.
稍后我们将看到，如何使用小数据样本以得到这 100或  101个参数，通常，我们会使用一种叫做正则化的线性代数方法，通过删除某些特征或者是使用某些技术，来解决当m比n小的时候的问题。即使你有一个相对较小的训练集，也可使用很多的特征来找到很多合适的参数。

**总之当你发现的矩阵 X'X的结果是奇异矩阵，或者找到的其它矩阵是不可逆的，要怎么做？**
首先，看特征值里是否有一些多余的特征，像这些 x1和x2是线性相关的，互为线性函数。同时，当有一些多余的特征时，可以删除这两个重复特征里的其中一个，无须两个特征同时保留，将解决不可逆性的问题。如果特征数量实在太多，我会删除些用较少的特征来反映尽可能多内容，否则我会考虑使用正规化方法。

# 拓展 广义线性模型与线性回归
线性回归是广义线性模型的一种特殊形式。
## 广义线性模型GLM
三个假设：
 - \\(y|x;\sim ExponentialFamily(\eta) \\)，即y的条件概率属于指数分布簇（The exponential Family）
 - 给定x广义线性模型的目标是求解\\(T(y)|x\\),不过由于很多情况下\\(T(y)=y\\),所以我们的目标就变成\\(y|x\\),也即我们希望拟合函数为\\(h(x)=E[y|x]\\) (备注：这个条件在线性回归中满足)
 - 自然参数\\(\eta\\)与\\(x\\)是线性关系：\\(\eta=\theta^Tx\\) (\\(\eta为向量时,\eta_i=\theta_i^Tx\\))

## 指数分布簇(The exponential Family）
首先定义一下指数分布，它有如下形式:
$$p(y;\eta)=b(y)exp(\eta^{T}T(y)-a(\eta)) \\\\
其中，\eta是自然参数(natural \\ parameter), \\\\ 
T(y)是充分统计量(sufficient \\ statistic,一般T(y)=y),\\\\
a(\eta)是log \\ partition \\ function(e^{-a(\eta)}充当正规化常量的角色，保证\sum p(y;\eta)=1)
$$
也就是说，T,a,b确定了一种分布，\\(\eta\\)是该分布的参数。选择合适的T,a,b我们可以得到高斯分布Gaussian和伯努利分布Bernoulli等。

即，有了广义线性模型，我们只需要把符合指数分布的一般模型的参数转换为它对应的广义线性模型参数，然后按照广义线性模型的求解步骤，即可轻松求解问题。

## Gaussian高斯分布的指数分布簇形式
在线性回归中，\\(\sigma对于模型参数\theta的选择没有影响，为了推导方便我们将其设为1：\\)
$$p(y;\mu)=\frac{1}{\sqrt{2\pi}}exp\left(-\frac{1}{2}(y-\mu)^2\right) \\\\
    = \frac{1}{\sqrt{2\pi}}exp\left(-\frac{1}{2}y^2\right)*exp\left(\mu y-\frac{1}{2}\mu^2\right)
$$
得到对应参数：
$$T(y)=y \\\\
\eta=\mu \\\\
a(\eta)=\mu^2/2=\eta^2/2 \\\\
b(y)=(1/\sqrt{2\pi})exp(-y^2/2)
$$
## 广义线性模型推导线性回归
我们重新审视一下线性回归,线性回归的表达如下：
$$y=\theta^TX+\epsilon$$
最重要的假设是，我们认为\\(\epsilon\\)满足均值为0，方差为\\(\sigma^2\\)的高斯分布，且满足\\(iid\\),即独立同分布,  $$\\\epsilon \sim N(0,\sigma^2)$$
因此有\\(E(\epsilon)=0\\),根据上述线性回归表达式我们实际上有，\\(E(y)=E(\theta^TX+\epsilon)\\), 可以得出y实际上是满足均值为\\(\theta^TX\\),方差为\\(\sigma^2\\)的高斯分布，这里的y可以写做\\(y|x;\theta\\),即：
$$y|x;\theta \sim N(\theta^TX,\sigma^2)$$

下面从广义线性模型角度进行推导：
 - step1: \\(y|x; \sim N(\mu,\theta)\\)
 - step2: 由假设2: \\(h(x)=E[y|x]\\) 得到：
  $$h_\theta(x)=E[y|x;\Theta]\\\\
   =\mu \\\\
   =\eta  \\\\
   =\Theta^Tx  \\\\
  其中, E[y|x;\Theta]=\mu由假设1得到；\\\\
  \mu=\eta由高斯分布对应的广义线性模型参数得到；\\\\
  \eta = \Theta^Tx由假设3得到。
  $$
可以看出\\(h_\theta(x)=E[y|x;\Theta]=\Theta^Tx\\), \\(h_\theta(x)\\)实际上就是\\(y|x;\theta\\)的期望，跟最初的假设是一致的。最后注意一下，\\(\theta\\)不是随机变量，我们把它看作是某个固定的值，我们要找到这个固定的值。

## 代价函数推导
根据前面的假设，我们知道\\(\epsilon\\)满足独立同分布。
根据最大似然估计法，我们定义：
$$L(\theta)=P(y|X;\theta)$$
我们希望每个样本出现的概率最大。再根据独立同分布假设以及高斯分布概率密度函数，我们有：
$$L(\theta)=P(y|X;\theta)=\prod_{i=1}^mP(y^{(i)}|x^{(i)};\theta) \\\\
=\prod_{i=1}^m\frac{1}{\sqrt{2\pi}\sigma}exp\left(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2}\right)
$$
两边取对数，有:
$$l(\theta)=log(L(\theta))=mlog(\frac{1}{\sqrt{2\pi}\sigma})+\sum_{i=1}^m\left(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2}\right)$$

为了使\\(l(\theta)\\)最大化，我们需要最小化：
$$\frac{1}{2}\sum_{i=1}^m(y^{(i)}-\theta^Tx^{(i)})^2$$
再调整系数，我们取样本平均，得到：
$$J(\theta)=\frac{1}{2m}\sum_{i=1}^m\left(h_{\theta}(x^{(i)})-y^{(i)}\right)^2$$

## 总结
可以看出，广义线性模型要求被解释变量属于指数分布簇。为什么呢？
逆推：被解释变量属于指数分布簇->被解释变可以写成指数分布的形式->其指数分布形式的参数\\(\eta\\)与原分布参数会发生联系->联系的方式是\\(\eta=f(原分布中的参数,比如\mu等，则f(\mu)即连接函数)\\)

# 参考
[斯坦福大学机器学习视频教程][22]
[知乎：为什么广义线性模型GLM要求被解释变量属于指数分布簇][23]
[知乎：广义线性模型][24]  






[1]: /picture/machine-learning/house_price.jpg
[2]: /picture/machine-learning/train_set_representation.jpg
[3]: /picture/machine-learning/supervised_learning.jpg
[4]: /picture/machine-learning/cost_function.jpg
[5]: /picture/machine-learning/modeling_error.jpg
[6]: /picture/machine-learning/contour.jpg
[7]: /picture/machine-learning/mini_.jpg
[8]: /picture/machine-learning/contour2.jpg
[9]: /picture/machine-learning/contour3.jpg
[10]: /picture/machine-learning/hill.jpg
[11]: /picture/machine-learning/gradient_descent.jpg
[12]: /picture/machine-learning/gradient_descent2.jpg
[13]: /picture/machine-learning/gradient_descent3.jpg
[14]: /picture/machine-learning/gradient_descent_line.jpg
[15]: /picture/machine-learning/multple_feature.jpg
[16]: /picture/machine-learning/feature_scale.jpg
[17]: /picture/machine-learning/feature_scale2.jpg
[18]: /picture/machine-learning/learn_rate.jpg
[19]: /picture/machine-learning/polynomial_regression.jpg
[20]: /picture/machine-learning/normal_example.jpg
[21]: /picture/machine-learning/normal_example2.jpg
[22]: http://open.163.com/special/opencourse/machinelearning.html
[23]: https://www.zhihu.com/question/47637500?sort=created
[24]: https://zhuanlan.zhihu.com/p/22876460